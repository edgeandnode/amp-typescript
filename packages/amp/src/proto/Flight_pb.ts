//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// <p>
// http://www.apache.org/licenses/LICENSE-2.0
// <p>
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=ts"
// @generated from file Flight.proto (package arrow.flight.protocol, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file Flight.proto.
 */
export const file_Flight: GenFile = /*@__PURE__*/
  fileDesc("CgxGbGlnaHQucHJvdG8SFWFycm93LmZsaWdodC5wcm90b2NvbCI9ChBIYW5kc2hha2VSZXF1ZXN0EhgKEHByb3RvY29sX3ZlcnNpb24YASABKAQSDwoHcGF5bG9hZBgCIAEoDCI+ChFIYW5kc2hha2VSZXNwb25zZRIYChBwcm90b2NvbF92ZXJzaW9uGAEgASgEEg8KB3BheWxvYWQYAiABKAwiLwoJQmFzaWNBdXRoEhAKCHVzZXJuYW1lGAIgASgJEhAKCHBhc3N3b3JkGAMgASgJIgcKBUVtcHR5Ii8KCkFjdGlvblR5cGUSDAoEdHlwZRgBIAEoCRITCgtkZXNjcmlwdGlvbhgCIAEoCSIeCghDcml0ZXJpYRISCgpleHByZXNzaW9uGAEgASgMIiQKBkFjdGlvbhIMCgR0eXBlGAEgASgJEgwKBGJvZHkYAiABKAwiFgoGUmVzdWx0EgwKBGJvZHkYASABKAwiHgoMU2NoZW1hUmVzdWx0Eg4KBnNjaGVtYRgBIAEoDCKlAQoQRmxpZ2h0RGVzY3JpcHRvchJECgR0eXBlGAEgASgOMjYuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERlc2NyaXB0b3IuRGVzY3JpcHRvclR5cGUSCwoDY21kGAIgASgMEgwKBHBhdGgYAyADKAkiMAoORGVzY3JpcHRvclR5cGUSCwoHVU5LTk9XThAAEggKBFBBVEgQARIHCgNDTUQQAiLsAQoKRmxpZ2h0SW5mbxIOCgZzY2hlbWEYASABKAwSQgoRZmxpZ2h0X2Rlc2NyaXB0b3IYAiABKAsyJy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RGVzY3JpcHRvchI3CghlbmRwb2ludBgDIAMoCzIlLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHRFbmRwb2ludBIVCg10b3RhbF9yZWNvcmRzGAQgASgDEhMKC3RvdGFsX2J5dGVzGAUgASgDEg8KB29yZGVyZWQYBiABKAgSFAoMYXBwX21ldGFkYXRhGAcgASgMItgBCghQb2xsSW5mbxIvCgRpbmZvGAEgASgLMiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodEluZm8SQgoRZmxpZ2h0X2Rlc2NyaXB0b3IYAiABKAsyJy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RGVzY3JpcHRvchIVCghwcm9ncmVzcxgDIAEoAUgAiAEBEjMKD2V4cGlyYXRpb25fdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBCCwoJX3Byb2dyZXNzIkoKF0NhbmNlbEZsaWdodEluZm9SZXF1ZXN0Ei8KBGluZm8YASABKAsyIS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0SW5mbyJNChZDYW5jZWxGbGlnaHRJbmZvUmVzdWx0EjMKBnN0YXR1cxgBIAEoDjIjLmFycm93LmZsaWdodC5wcm90b2NvbC5DYW5jZWxTdGF0dXMiGAoGVGlja2V0Eg4KBnRpY2tldBgBIAEoDCIXCghMb2NhdGlvbhILCgN1cmkYASABKAkivQEKDkZsaWdodEVuZHBvaW50Ei0KBnRpY2tldBgBIAEoCzIdLmFycm93LmZsaWdodC5wcm90b2NvbC5UaWNrZXQSMQoIbG9jYXRpb24YAiADKAsyHy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuTG9jYXRpb24SMwoPZXhwaXJhdGlvbl90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIUCgxhcHBfbWV0YWRhdGEYBCABKAwiVQoaUmVuZXdGbGlnaHRFbmRwb2ludFJlcXVlc3QSNwoIZW5kcG9pbnQYASABKAsyJS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RW5kcG9pbnQijwEKCkZsaWdodERhdGESQgoRZmxpZ2h0X2Rlc2NyaXB0b3IYASABKAsyJy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RGVzY3JpcHRvchITCgtkYXRhX2hlYWRlchgCIAEoDBIUCgxhcHBfbWV0YWRhdGEYAyABKAwSEgoJZGF0YV9ib2R5GOgHIAEoDCIhCglQdXRSZXN1bHQSFAoMYXBwX21ldGFkYXRhGAEgASgMIvwBChJTZXNzaW9uT3B0aW9uVmFsdWUSFgoMc3RyaW5nX3ZhbHVlGAEgASgJSAASFAoKYm9vbF92YWx1ZRgCIAEoCEgAEhUKC2ludDY0X3ZhbHVlGAMgASgQSAASFgoMZG91YmxlX3ZhbHVlGAQgASgBSAASVgoRc3RyaW5nX2xpc3RfdmFsdWUYBSABKAsyOS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuU2Vzc2lvbk9wdGlvblZhbHVlLlN0cmluZ0xpc3RWYWx1ZUgAGiEKD1N0cmluZ0xpc3RWYWx1ZRIOCgZ2YWx1ZXMYASADKAlCDgoMb3B0aW9uX3ZhbHVlItoBChhTZXRTZXNzaW9uT3B0aW9uc1JlcXVlc3QSXAoPc2Vzc2lvbl9vcHRpb25zGAEgAygLMkMuYXJyb3cuZmxpZ2h0LnByb3RvY29sLlNldFNlc3Npb25PcHRpb25zUmVxdWVzdC5TZXNzaW9uT3B0aW9uc0VudHJ5GmAKE1Nlc3Npb25PcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEjgKBXZhbHVlGAIgASgLMikuYXJyb3cuZmxpZ2h0LnByb3RvY29sLlNlc3Npb25PcHRpb25WYWx1ZToCOAEi7AIKF1NldFNlc3Npb25PcHRpb25zUmVzdWx0EkoKBmVycm9ycxgBIAMoCzI6LmFycm93LmZsaWdodC5wcm90b2NvbC5TZXRTZXNzaW9uT3B0aW9uc1Jlc3VsdC5FcnJvcnNFbnRyeRpRCgVFcnJvchJICgV2YWx1ZRgBIAEoDjI5LmFycm93LmZsaWdodC5wcm90b2NvbC5TZXRTZXNzaW9uT3B0aW9uc1Jlc3VsdC5FcnJvclZhbHVlGmMKC0Vycm9yc0VudHJ5EgsKA2tleRgBIAEoCRJDCgV2YWx1ZRgCIAEoCzI0LmFycm93LmZsaWdodC5wcm90b2NvbC5TZXRTZXNzaW9uT3B0aW9uc1Jlc3VsdC5FcnJvcjoCOAEiTQoKRXJyb3JWYWx1ZRIPCgtVTlNQRUNJRklFRBAAEhAKDElOVkFMSURfTkFNRRABEhEKDUlOVkFMSURfVkFMVUUQAhIJCgVFUlJPUhADIhoKGEdldFNlc3Npb25PcHRpb25zUmVxdWVzdCLYAQoXR2V0U2Vzc2lvbk9wdGlvbnNSZXN1bHQSWwoPc2Vzc2lvbl9vcHRpb25zGAEgAygLMkIuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkdldFNlc3Npb25PcHRpb25zUmVzdWx0LlNlc3Npb25PcHRpb25zRW50cnkaYAoTU2Vzc2lvbk9wdGlvbnNFbnRyeRILCgNrZXkYASABKAkSOAoFdmFsdWUYAiABKAsyKS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuU2Vzc2lvbk9wdGlvblZhbHVlOgI4ASIVChNDbG9zZVNlc3Npb25SZXF1ZXN0Ip0BChJDbG9zZVNlc3Npb25SZXN1bHQSQAoGc3RhdHVzGAEgASgOMjAuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkNsb3NlU2Vzc2lvblJlc3VsdC5TdGF0dXMiRQoGU3RhdHVzEg8KC1VOU1BFQ0lGSUVEEAASCgoGQ0xPU0VEEAESCwoHQ0xPU0lORxACEhEKDU5PVF9DTE9TRUFCTEUQAyqLAQoMQ2FuY2VsU3RhdHVzEh0KGUNBTkNFTF9TVEFUVVNfVU5TUEVDSUZJRUQQABIbChdDQU5DRUxfU1RBVFVTX0NBTkNFTExFRBABEhwKGENBTkNFTF9TVEFUVVNfQ0FOQ0VMTElORxACEiEKHUNBTkNFTF9TVEFUVVNfTk9UX0NBTkNFTExBQkxFEAMyhQcKDUZsaWdodFNlcnZpY2USZAoJSGFuZHNoYWtlEicuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkhhbmRzaGFrZVJlcXVlc3QaKC5hcnJvdy5mbGlnaHQucHJvdG9jb2wuSGFuZHNoYWtlUmVzcG9uc2UiACgBMAESVQoLTGlzdEZsaWdodHMSHy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuQ3JpdGVyaWEaIS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0SW5mbyIAMAESXQoNR2V0RmxpZ2h0SW5mbxInLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREZXNjcmlwdG9yGiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodEluZm8iABJcCg5Qb2xsRmxpZ2h0SW5mbxInLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREZXNjcmlwdG9yGh8uYXJyb3cuZmxpZ2h0LnByb3RvY29sLlBvbGxJbmZvIgASWwoJR2V0U2NoZW1hEicuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERlc2NyaXB0b3IaIy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuU2NoZW1hUmVzdWx0IgASTQoFRG9HZXQSHS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuVGlja2V0GiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERhdGEiADABElIKBURvUHV0EiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkZsaWdodERhdGEaIC5hcnJvdy5mbGlnaHQucHJvdG9jb2wuUHV0UmVzdWx0IgAoATABElgKCkRvRXhjaGFuZ2USIS5hcnJvdy5mbGlnaHQucHJvdG9jb2wuRmxpZ2h0RGF0YRohLmFycm93LmZsaWdodC5wcm90b2NvbC5GbGlnaHREYXRhIgAoATABEkwKCERvQWN0aW9uEh0uYXJyb3cuZmxpZ2h0LnByb3RvY29sLkFjdGlvbhodLmFycm93LmZsaWdodC5wcm90b2NvbC5SZXN1bHQiADABElIKC0xpc3RBY3Rpb25zEhwuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkVtcHR5GiEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLkFjdGlvblR5cGUiADABQnEKHG9yZy5hcGFjaGUuYXJyb3cuZmxpZ2h0LmltcGxaMmdpdGh1Yi5jb20vYXBhY2hlL2Fycm93LWdvL2Fycm93L2ZsaWdodC9nZW4vZmxpZ2h0qgIcQXBhY2hlLkFycm93LkZsaWdodC5Qcm90b2NvbGIGcHJvdG8z", [file_google_protobuf_timestamp]);

/**
 *
 * The request that a client provides to a server on handshake.
 *
 * @generated from message arrow.flight.protocol.HandshakeRequest
 */
export type HandshakeRequest = Message<"arrow.flight.protocol.HandshakeRequest"> & {
  /**
   *
   * A defined protocol version
   *
   * @generated from field: uint64 protocol_version = 1;
   */
  protocolVersion: bigint;

  /**
   *
   * Arbitrary auth/handshake info.
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.HandshakeRequest.
 * Use `create(HandshakeRequestSchema)` to create a new message.
 */
export const HandshakeRequestSchema: GenMessage<HandshakeRequest> = /*@__PURE__*/
  messageDesc(file_Flight, 0);

/**
 * @generated from message arrow.flight.protocol.HandshakeResponse
 */
export type HandshakeResponse = Message<"arrow.flight.protocol.HandshakeResponse"> & {
  /**
   *
   * A defined protocol version
   *
   * @generated from field: uint64 protocol_version = 1;
   */
  protocolVersion: bigint;

  /**
   *
   * Arbitrary auth/handshake info.
   *
   * @generated from field: bytes payload = 2;
   */
  payload: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.HandshakeResponse.
 * Use `create(HandshakeResponseSchema)` to create a new message.
 */
export const HandshakeResponseSchema: GenMessage<HandshakeResponse> = /*@__PURE__*/
  messageDesc(file_Flight, 1);

/**
 *
 * A message for doing simple auth.
 *
 * @generated from message arrow.flight.protocol.BasicAuth
 */
export type BasicAuth = Message<"arrow.flight.protocol.BasicAuth"> & {
  /**
   * @generated from field: string username = 2;
   */
  username: string;

  /**
   * @generated from field: string password = 3;
   */
  password: string;
};

/**
 * Describes the message arrow.flight.protocol.BasicAuth.
 * Use `create(BasicAuthSchema)` to create a new message.
 */
export const BasicAuthSchema: GenMessage<BasicAuth> = /*@__PURE__*/
  messageDesc(file_Flight, 2);

/**
 * @generated from message arrow.flight.protocol.Empty
 */
export type Empty = Message<"arrow.flight.protocol.Empty"> & {
};

/**
 * Describes the message arrow.flight.protocol.Empty.
 * Use `create(EmptySchema)` to create a new message.
 */
export const EmptySchema: GenMessage<Empty> = /*@__PURE__*/
  messageDesc(file_Flight, 3);

/**
 *
 * Describes an available action, including both the name used for execution
 * along with a short description of the purpose of the action.
 *
 * @generated from message arrow.flight.protocol.ActionType
 */
export type ActionType = Message<"arrow.flight.protocol.ActionType"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: string description = 2;
   */
  description: string;
};

/**
 * Describes the message arrow.flight.protocol.ActionType.
 * Use `create(ActionTypeSchema)` to create a new message.
 */
export const ActionTypeSchema: GenMessage<ActionType> = /*@__PURE__*/
  messageDesc(file_Flight, 4);

/**
 *
 * A service specific expression that can be used to return a limited set
 * of available Arrow Flight streams.
 *
 * @generated from message arrow.flight.protocol.Criteria
 */
export type Criteria = Message<"arrow.flight.protocol.Criteria"> & {
  /**
   * @generated from field: bytes expression = 1;
   */
  expression: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Criteria.
 * Use `create(CriteriaSchema)` to create a new message.
 */
export const CriteriaSchema: GenMessage<Criteria> = /*@__PURE__*/
  messageDesc(file_Flight, 5);

/**
 *
 * An opaque action specific for the service.
 *
 * @generated from message arrow.flight.protocol.Action
 */
export type Action = Message<"arrow.flight.protocol.Action"> & {
  /**
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * @generated from field: bytes body = 2;
   */
  body: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Action.
 * Use `create(ActionSchema)` to create a new message.
 */
export const ActionSchema: GenMessage<Action> = /*@__PURE__*/
  messageDesc(file_Flight, 6);

/**
 *
 * An opaque result returned after executing an action.
 *
 * @generated from message arrow.flight.protocol.Result
 */
export type Result = Message<"arrow.flight.protocol.Result"> & {
  /**
   * @generated from field: bytes body = 1;
   */
  body: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Result.
 * Use `create(ResultSchema)` to create a new message.
 */
export const ResultSchema: GenMessage<Result> = /*@__PURE__*/
  messageDesc(file_Flight, 7);

/**
 *
 * Wrap the result of a getSchema call
 *
 * @generated from message arrow.flight.protocol.SchemaResult
 */
export type SchemaResult = Message<"arrow.flight.protocol.SchemaResult"> & {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   *
   * @generated from field: bytes schema = 1;
   */
  schema: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.SchemaResult.
 * Use `create(SchemaResultSchema)` to create a new message.
 */
export const SchemaResultSchema: GenMessage<SchemaResult> = /*@__PURE__*/
  messageDesc(file_Flight, 8);

/**
 *
 * The name or tag for a Flight. May be used as a way to retrieve or generate
 * a flight or be used to expose a set of previously defined flights.
 *
 * @generated from message arrow.flight.protocol.FlightDescriptor
 */
export type FlightDescriptor = Message<"arrow.flight.protocol.FlightDescriptor"> & {
  /**
   * @generated from field: arrow.flight.protocol.FlightDescriptor.DescriptorType type = 1;
   */
  type: FlightDescriptor_DescriptorType;

  /**
   *
   * Opaque value used to express a command. Should only be defined when
   * type = CMD.
   *
   * @generated from field: bytes cmd = 2;
   */
  cmd: Uint8Array;

  /**
   *
   * List of strings identifying a particular dataset. Should only be defined
   * when type = PATH.
   *
   * @generated from field: repeated string path = 3;
   */
  path: string[];
};

/**
 * Describes the message arrow.flight.protocol.FlightDescriptor.
 * Use `create(FlightDescriptorSchema)` to create a new message.
 */
export const FlightDescriptorSchema: GenMessage<FlightDescriptor> = /*@__PURE__*/
  messageDesc(file_Flight, 9);

/**
 *
 * Describes what type of descriptor is defined.
 *
 * @generated from enum arrow.flight.protocol.FlightDescriptor.DescriptorType
 */
export enum FlightDescriptor_DescriptorType {
  /**
   * Protobuf pattern, not used.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   *
   * A named path that identifies a dataset. A path is composed of a string
   * or list of strings describing a particular dataset. This is conceptually
   *  similar to a path inside a filesystem.
   *
   * @generated from enum value: PATH = 1;
   */
  PATH = 1,

  /**
   *
   * An opaque command to generate a dataset.
   *
   * @generated from enum value: CMD = 2;
   */
  CMD = 2,
}

/**
 * Describes the enum arrow.flight.protocol.FlightDescriptor.DescriptorType.
 */
export const FlightDescriptor_DescriptorTypeSchema: GenEnum<FlightDescriptor_DescriptorType> = /*@__PURE__*/
  enumDesc(file_Flight, 9, 0);

/**
 *
 * The access coordinates for retrieval of a dataset. With a FlightInfo, a
 * consumer is able to determine how to retrieve a dataset.
 *
 * @generated from message arrow.flight.protocol.FlightInfo
 */
export type FlightInfo = Message<"arrow.flight.protocol.FlightInfo"> & {
  /**
   * The schema of the dataset in its IPC form:
   *   4 bytes - an optional IPC_CONTINUATION_TOKEN prefix
   *   4 bytes - the byte length of the payload
   *   a flatbuffer Message whose header is the Schema
   *
   * @generated from field: bytes schema = 1;
   */
  schema: Uint8Array;

  /**
   *
   * The descriptor associated with this info.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   *
   * A list of endpoints associated with the flight. To consume the
   * whole flight, all endpoints (and hence all Tickets) must be
   * consumed. Endpoints can be consumed in any order.
   *
   * In other words, an application can use multiple endpoints to
   * represent partitioned data.
   *
   * If the returned data has an ordering, an application can use
   * "FlightInfo.ordered = true" or should return the all data in a
   * single endpoint. Otherwise, there is no ordering defined on
   * endpoints or the data within.
   *
   * A client can read ordered data by reading data from returned
   * endpoints, in order, from front to back.
   *
   * Note that a client may ignore "FlightInfo.ordered = true". If an
   * ordering is important for an application, an application must
   * choose one of them:
   *
   * * An application requires that all clients must read data in
   *   returned endpoints order.
   * * An application must return the all data in a single endpoint.
   *
   * @generated from field: repeated arrow.flight.protocol.FlightEndpoint endpoint = 3;
   */
  endpoint: FlightEndpoint[];

  /**
   * Set these to -1 if unknown.
   *
   * @generated from field: int64 total_records = 4;
   */
  totalRecords: bigint;

  /**
   * @generated from field: int64 total_bytes = 5;
   */
  totalBytes: bigint;

  /**
   *
   * FlightEndpoints are in the same order as the data.
   *
   * @generated from field: bool ordered = 6;
   */
  ordered: boolean;

  /**
   *
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightEndpoints or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   *
   * @generated from field: bytes app_metadata = 7;
   */
  appMetadata: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.FlightInfo.
 * Use `create(FlightInfoSchema)` to create a new message.
 */
export const FlightInfoSchema: GenMessage<FlightInfo> = /*@__PURE__*/
  messageDesc(file_Flight, 10);

/**
 *
 * The information to process a long-running query.
 *
 * @generated from message arrow.flight.protocol.PollInfo
 */
export type PollInfo = Message<"arrow.flight.protocol.PollInfo"> & {
  /**
   *
   * The currently available results.
   *
   * If "flight_descriptor" is not specified, the query is complete
   * and "info" specifies all results. Otherwise, "info" contains
   * partial query results.
   *
   * Note that each PollInfo response contains a complete
   * FlightInfo (not just the delta between the previous and current
   * FlightInfo).
   *
   * Subsequent PollInfo responses may only append new endpoints to
   * info.
   *
   * Clients can begin fetching results via DoGet(Ticket) with the
   * ticket in the info before the query is
   * completed. FlightInfo.ordered is also valid.
   *
   * @generated from field: arrow.flight.protocol.FlightInfo info = 1;
   */
  info?: FlightInfo;

  /**
   *
   * The descriptor the client should use on the next try.
   * If unset, the query is complete.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 2;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   *
   * Query progress. If known, must be in [0.0, 1.0] but need not be
   * monotonic or nondecreasing. If unknown, do not set.
   *
   * @generated from field: optional double progress = 3;
   */
  progress?: number;

  /**
   *
   * Expiration time for this request. After this passes, the server
   * might not accept the retry descriptor anymore (and the query may
   * be cancelled). This may be updated on a call to PollFlightInfo.
   *
   * @generated from field: google.protobuf.Timestamp expiration_time = 4;
   */
  expirationTime?: Timestamp;
};

/**
 * Describes the message arrow.flight.protocol.PollInfo.
 * Use `create(PollInfoSchema)` to create a new message.
 */
export const PollInfoSchema: GenMessage<PollInfo> = /*@__PURE__*/
  messageDesc(file_Flight, 11);

/**
 *
 * The request of the CancelFlightInfo action.
 *
 * The request should be stored in Action.body.
 *
 * @generated from message arrow.flight.protocol.CancelFlightInfoRequest
 */
export type CancelFlightInfoRequest = Message<"arrow.flight.protocol.CancelFlightInfoRequest"> & {
  /**
   * @generated from field: arrow.flight.protocol.FlightInfo info = 1;
   */
  info?: FlightInfo;
};

/**
 * Describes the message arrow.flight.protocol.CancelFlightInfoRequest.
 * Use `create(CancelFlightInfoRequestSchema)` to create a new message.
 */
export const CancelFlightInfoRequestSchema: GenMessage<CancelFlightInfoRequest> = /*@__PURE__*/
  messageDesc(file_Flight, 12);

/**
 *
 * The result of the CancelFlightInfo action.
 *
 * The result should be stored in Result.body.
 *
 * @generated from message arrow.flight.protocol.CancelFlightInfoResult
 */
export type CancelFlightInfoResult = Message<"arrow.flight.protocol.CancelFlightInfoResult"> & {
  /**
   * @generated from field: arrow.flight.protocol.CancelStatus status = 1;
   */
  status: CancelStatus;
};

/**
 * Describes the message arrow.flight.protocol.CancelFlightInfoResult.
 * Use `create(CancelFlightInfoResultSchema)` to create a new message.
 */
export const CancelFlightInfoResultSchema: GenMessage<CancelFlightInfoResult> = /*@__PURE__*/
  messageDesc(file_Flight, 13);

/**
 *
 * An opaque identifier that the service can use to retrieve a particular
 * portion of a stream.
 *
 * Tickets are meant to be single use. It is an error/application-defined
 * behavior to reuse a ticket.
 *
 * @generated from message arrow.flight.protocol.Ticket
 */
export type Ticket = Message<"arrow.flight.protocol.Ticket"> & {
  /**
   * @generated from field: bytes ticket = 1;
   */
  ticket: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.Ticket.
 * Use `create(TicketSchema)` to create a new message.
 */
export const TicketSchema: GenMessage<Ticket> = /*@__PURE__*/
  messageDesc(file_Flight, 14);

/**
 *
 * A location to retrieve a particular stream from. This URI should be one of
 * the following:
 *  - An empty string or the string 'arrow-flight-reuse-connection://?':
 *    indicating that the ticket can be redeemed on the service where the
 *    ticket was generated via a DoGet request.
 *  - A valid grpc URI (grpc://, grpc+tls://, grpc+unix://, etc.):
 *    indicating that the ticket can be redeemed on the service at the given
 *    URI via a DoGet request.
 *  - A valid HTTP URI (http://, https://, etc.):
 *    indicating that the client should perform a GET request against the
 *    given URI to retrieve the stream. The ticket should be empty
 *    in this case and should be ignored by the client. Cloud object storage
 *    can be utilized by presigned URLs or mediating the auth separately and
 *    returning the full URL (e.g. https://amzn-s3-demo-bucket.s3.us-west-2.amazonaws.com/...).
 *
 * We allow non-Flight URIs for the purpose of allowing Flight services to indicate that
 * results can be downloaded in formats other than Arrow (such as Parquet) or to allow
 * direct fetching of results from a URI to reduce excess copying and data movement.
 * In these cases, the following conventions should be followed by servers and clients:
 *
 *  - Unless otherwise specified by the 'Content-Type' header of the response,
 *    a client should assume the response is using the Arrow IPC Streaming format.
 *    Usage of an IANA media type like 'application/octet-stream' should be assumed to
 *    be using the Arrow IPC Streaming format.
 *  - The server may allow the client to choose a specific response format by
 *    specifying an 'Accept' header in the request, such as 'application/vnd.apache.parquet'
 *    or 'application/vnd.apache.arrow.stream'. If multiple types are requested and
 *    supported by the server, the choice of which to use is server-specific. If
 *    none of the requested content-types are supported, the server may respond with
 *    either 406 (Not Acceptable) or 415 (Unsupported Media Type), or successfully
 *    respond with a different format that it does support along with the correct
 *    'Content-Type' header.
 *
 * Note: new schemes may be proposed in the future to allow for more flexibility based
 * on community requests.
 *
 * @generated from message arrow.flight.protocol.Location
 */
export type Location = Message<"arrow.flight.protocol.Location"> & {
  /**
   * @generated from field: string uri = 1;
   */
  uri: string;
};

/**
 * Describes the message arrow.flight.protocol.Location.
 * Use `create(LocationSchema)` to create a new message.
 */
export const LocationSchema: GenMessage<Location> = /*@__PURE__*/
  messageDesc(file_Flight, 15);

/**
 *
 * A particular stream or split associated with a flight.
 *
 * @generated from message arrow.flight.protocol.FlightEndpoint
 */
export type FlightEndpoint = Message<"arrow.flight.protocol.FlightEndpoint"> & {
  /**
   *
   * Token used to retrieve this stream.
   *
   * @generated from field: arrow.flight.protocol.Ticket ticket = 1;
   */
  ticket?: Ticket;

  /**
   *
   * A list of URIs where this ticket can be redeemed via DoGet().
   *
   * If the list is empty, the expectation is that the ticket can only
   * be redeemed on the current service where the ticket was
   * generated.
   *
   * If the list is not empty, the expectation is that the ticket can be
   * redeemed at any of the locations, and that the data returned will be
   * equivalent. In this case, the ticket may only be redeemed at one of the
   * given locations, and not (necessarily) on the current service. If one
   * of the given locations is "arrow-flight-reuse-connection://?", the
   * client may redeem the ticket on the service where the ticket was
   * generated (i.e., the same as above), in addition to the other
   * locations. (This URI was chosen to maximize compatibility, as 'scheme:'
   * or 'scheme://' are not accepted by Java's java.net.URI.)
   *
   * In other words, an application can use multiple locations to
   * represent redundant and/or load balanced services.
   *
   * @generated from field: repeated arrow.flight.protocol.Location location = 2;
   */
  location: Location[];

  /**
   *
   * Expiration time of this stream. If present, clients may assume
   * they can retry DoGet requests. Otherwise, it is
   * application-defined whether DoGet requests may be retried.
   *
   * @generated from field: google.protobuf.Timestamp expiration_time = 3;
   */
  expirationTime?: Timestamp;

  /**
   *
   * Application-defined metadata.
   *
   * There is no inherent or required relationship between this
   * and the app_metadata fields in the FlightInfo or resulting
   * FlightData messages. Since this metadata is application-defined,
   * a given application could define there to be a relationship,
   * but there is none required by the spec.
   *
   * @generated from field: bytes app_metadata = 4;
   */
  appMetadata: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.FlightEndpoint.
 * Use `create(FlightEndpointSchema)` to create a new message.
 */
export const FlightEndpointSchema: GenMessage<FlightEndpoint> = /*@__PURE__*/
  messageDesc(file_Flight, 16);

/**
 *
 * The request of the RenewFlightEndpoint action.
 *
 * The request should be stored in Action.body.
 *
 * @generated from message arrow.flight.protocol.RenewFlightEndpointRequest
 */
export type RenewFlightEndpointRequest = Message<"arrow.flight.protocol.RenewFlightEndpointRequest"> & {
  /**
   * @generated from field: arrow.flight.protocol.FlightEndpoint endpoint = 1;
   */
  endpoint?: FlightEndpoint;
};

/**
 * Describes the message arrow.flight.protocol.RenewFlightEndpointRequest.
 * Use `create(RenewFlightEndpointRequestSchema)` to create a new message.
 */
export const RenewFlightEndpointRequestSchema: GenMessage<RenewFlightEndpointRequest> = /*@__PURE__*/
  messageDesc(file_Flight, 17);

/**
 *
 * A batch of Arrow data as part of a stream of batches.
 *
 * @generated from message arrow.flight.protocol.FlightData
 */
export type FlightData = Message<"arrow.flight.protocol.FlightData"> & {
  /**
   *
   * The descriptor of the data. This is only relevant when a client is
   * starting a new DoPut stream.
   *
   * @generated from field: arrow.flight.protocol.FlightDescriptor flight_descriptor = 1;
   */
  flightDescriptor?: FlightDescriptor;

  /**
   *
   * Header for message data as described in Message.fbs::Message.
   *
   * @generated from field: bytes data_header = 2;
   */
  dataHeader: Uint8Array;

  /**
   *
   * Application-defined metadata.
   *
   * @generated from field: bytes app_metadata = 3;
   */
  appMetadata: Uint8Array;

  /**
   *
   * The actual batch of Arrow data. Preferably handled with minimal-copies
   * coming last in the definition to help with sidecar patterns (it is
   * expected that some implementations will fetch this field off the wire
   * with specialized code to avoid extra memory copies).
   *
   * @generated from field: bytes data_body = 1000;
   */
  dataBody: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.FlightData.
 * Use `create(FlightDataSchema)` to create a new message.
 */
export const FlightDataSchema: GenMessage<FlightData> = /*@__PURE__*/
  messageDesc(file_Flight, 18);

/**
 * *
 * The response message associated with the submission of a DoPut.
 *
 * @generated from message arrow.flight.protocol.PutResult
 */
export type PutResult = Message<"arrow.flight.protocol.PutResult"> & {
  /**
   * @generated from field: bytes app_metadata = 1;
   */
  appMetadata: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.PutResult.
 * Use `create(PutResultSchema)` to create a new message.
 */
export const PutResultSchema: GenMessage<PutResult> = /*@__PURE__*/
  messageDesc(file_Flight, 19);

/**
 *
 * EXPERIMENTAL: Union of possible value types for a Session Option to be set to.
 *
 * By convention, an attempt to set a valueless SessionOptionValue should
 * attempt to unset or clear the named option value on the server.
 *
 * @generated from message arrow.flight.protocol.SessionOptionValue
 */
export type SessionOptionValue = Message<"arrow.flight.protocol.SessionOptionValue"> & {
  /**
   * @generated from oneof arrow.flight.protocol.SessionOptionValue.option_value
   */
  optionValue: {
    /**
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: bool bool_value = 2;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * @generated from field: sfixed64 int64_value = 3;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * @generated from field: double double_value = 4;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * @generated from field: arrow.flight.protocol.SessionOptionValue.StringListValue string_list_value = 5;
     */
    value: SessionOptionValue_StringListValue;
    case: "stringListValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message arrow.flight.protocol.SessionOptionValue.
 * Use `create(SessionOptionValueSchema)` to create a new message.
 */
export const SessionOptionValueSchema: GenMessage<SessionOptionValue> = /*@__PURE__*/
  messageDesc(file_Flight, 20);

/**
 * @generated from message arrow.flight.protocol.SessionOptionValue.StringListValue
 */
export type SessionOptionValue_StringListValue = Message<"arrow.flight.protocol.SessionOptionValue.StringListValue"> & {
  /**
   * @generated from field: repeated string values = 1;
   */
  values: string[];
};

/**
 * Describes the message arrow.flight.protocol.SessionOptionValue.StringListValue.
 * Use `create(SessionOptionValue_StringListValueSchema)` to create a new message.
 */
export const SessionOptionValue_StringListValueSchema: GenMessage<SessionOptionValue_StringListValue> = /*@__PURE__*/
  messageDesc(file_Flight, 20, 0);

/**
 *
 * EXPERIMENTAL: A request to set session options for an existing or new (implicit)
 * server session.
 *
 * Sessions are persisted and referenced via a transport-level state management, typically
 * RFC 6265 HTTP cookies when using an HTTP transport.  The suggested cookie name or state
 * context key is 'arrow_flight_session_id', although implementations may freely choose their
 * own name.
 *
 * Session creation (if one does not already exist) is implied by this RPC request, however
 * server implementations may choose to initiate a session that also contains client-provided
 * session options at any other time, e.g. on authentication, or when any other call is made
 * and the server wishes to use a session to persist any state (or lack thereof).
 *
 * @generated from message arrow.flight.protocol.SetSessionOptionsRequest
 */
export type SetSessionOptionsRequest = Message<"arrow.flight.protocol.SetSessionOptionsRequest"> & {
  /**
   * @generated from field: map<string, arrow.flight.protocol.SessionOptionValue> session_options = 1;
   */
  sessionOptions: { [key: string]: SessionOptionValue };
};

/**
 * Describes the message arrow.flight.protocol.SetSessionOptionsRequest.
 * Use `create(SetSessionOptionsRequestSchema)` to create a new message.
 */
export const SetSessionOptionsRequestSchema: GenMessage<SetSessionOptionsRequest> = /*@__PURE__*/
  messageDesc(file_Flight, 21);

/**
 *
 * EXPERIMENTAL: The results (individually) of setting a set of session options.
 *
 * Option names should only be present in the response if they were not successfully
 * set on the server; that is, a response without an Error for a name provided in the
 * SetSessionOptionsRequest implies that the named option value was set successfully.
 *
 * @generated from message arrow.flight.protocol.SetSessionOptionsResult
 */
export type SetSessionOptionsResult = Message<"arrow.flight.protocol.SetSessionOptionsResult"> & {
  /**
   * @generated from field: map<string, arrow.flight.protocol.SetSessionOptionsResult.Error> errors = 1;
   */
  errors: { [key: string]: SetSessionOptionsResult_Error };
};

/**
 * Describes the message arrow.flight.protocol.SetSessionOptionsResult.
 * Use `create(SetSessionOptionsResultSchema)` to create a new message.
 */
export const SetSessionOptionsResultSchema: GenMessage<SetSessionOptionsResult> = /*@__PURE__*/
  messageDesc(file_Flight, 22);

/**
 * @generated from message arrow.flight.protocol.SetSessionOptionsResult.Error
 */
export type SetSessionOptionsResult_Error = Message<"arrow.flight.protocol.SetSessionOptionsResult.Error"> & {
  /**
   * @generated from field: arrow.flight.protocol.SetSessionOptionsResult.ErrorValue value = 1;
   */
  value: SetSessionOptionsResult_ErrorValue;
};

/**
 * Describes the message arrow.flight.protocol.SetSessionOptionsResult.Error.
 * Use `create(SetSessionOptionsResult_ErrorSchema)` to create a new message.
 */
export const SetSessionOptionsResult_ErrorSchema: GenMessage<SetSessionOptionsResult_Error> = /*@__PURE__*/
  messageDesc(file_Flight, 22, 0);

/**
 * @generated from enum arrow.flight.protocol.SetSessionOptionsResult.ErrorValue
 */
export enum SetSessionOptionsResult_ErrorValue {
  /**
   * Protobuf deserialization fallback value: The status is unknown or unrecognized.
   * Servers should avoid using this value. The request may be retried by the client.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The given session option name is invalid.
   *
   * @generated from enum value: INVALID_NAME = 1;
   */
  INVALID_NAME = 1,

  /**
   * The session option value or type is invalid.
   *
   * @generated from enum value: INVALID_VALUE = 2;
   */
  INVALID_VALUE = 2,

  /**
   * The session option cannot be set.
   *
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,
}

/**
 * Describes the enum arrow.flight.protocol.SetSessionOptionsResult.ErrorValue.
 */
export const SetSessionOptionsResult_ErrorValueSchema: GenEnum<SetSessionOptionsResult_ErrorValue> = /*@__PURE__*/
  enumDesc(file_Flight, 22, 0);

/**
 *
 * EXPERIMENTAL: A request to access the session options for the current server session.
 *
 * The existing session is referenced via a cookie header or similar (see
 * SetSessionOptionsRequest above); it is an error to make this request with a missing,
 * invalid, or expired session cookie header or other implementation-defined session
 * reference token.
 *
 * @generated from message arrow.flight.protocol.GetSessionOptionsRequest
 */
export type GetSessionOptionsRequest = Message<"arrow.flight.protocol.GetSessionOptionsRequest"> & {
};

/**
 * Describes the message arrow.flight.protocol.GetSessionOptionsRequest.
 * Use `create(GetSessionOptionsRequestSchema)` to create a new message.
 */
export const GetSessionOptionsRequestSchema: GenMessage<GetSessionOptionsRequest> = /*@__PURE__*/
  messageDesc(file_Flight, 23);

/**
 *
 * EXPERIMENTAL: The result containing the current server session options.
 *
 * @generated from message arrow.flight.protocol.GetSessionOptionsResult
 */
export type GetSessionOptionsResult = Message<"arrow.flight.protocol.GetSessionOptionsResult"> & {
  /**
   * @generated from field: map<string, arrow.flight.protocol.SessionOptionValue> session_options = 1;
   */
  sessionOptions: { [key: string]: SessionOptionValue };
};

/**
 * Describes the message arrow.flight.protocol.GetSessionOptionsResult.
 * Use `create(GetSessionOptionsResultSchema)` to create a new message.
 */
export const GetSessionOptionsResultSchema: GenMessage<GetSessionOptionsResult> = /*@__PURE__*/
  messageDesc(file_Flight, 24);

/**
 *
 * Request message for the "Close Session" action.
 *
 * The exiting session is referenced via a cookie header.
 *
 * @generated from message arrow.flight.protocol.CloseSessionRequest
 */
export type CloseSessionRequest = Message<"arrow.flight.protocol.CloseSessionRequest"> & {
};

/**
 * Describes the message arrow.flight.protocol.CloseSessionRequest.
 * Use `create(CloseSessionRequestSchema)` to create a new message.
 */
export const CloseSessionRequestSchema: GenMessage<CloseSessionRequest> = /*@__PURE__*/
  messageDesc(file_Flight, 25);

/**
 *
 * The result of closing a session.
 *
 * @generated from message arrow.flight.protocol.CloseSessionResult
 */
export type CloseSessionResult = Message<"arrow.flight.protocol.CloseSessionResult"> & {
  /**
   * @generated from field: arrow.flight.protocol.CloseSessionResult.Status status = 1;
   */
  status: CloseSessionResult_Status;
};

/**
 * Describes the message arrow.flight.protocol.CloseSessionResult.
 * Use `create(CloseSessionResultSchema)` to create a new message.
 */
export const CloseSessionResultSchema: GenMessage<CloseSessionResult> = /*@__PURE__*/
  messageDesc(file_Flight, 26);

/**
 * @generated from enum arrow.flight.protocol.CloseSessionResult.Status
 */
export enum CloseSessionResult_Status {
  /**
   * Protobuf deserialization fallback value: The session close status is unknown or
   * not recognized. Servers should avoid using this value (send a NOT_FOUND error if
   * the requested session is not known or expired). Clients can retry the request.
   *
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The session close request is complete. Subsequent requests with
   * the same session produce a NOT_FOUND error.
   *
   * @generated from enum value: CLOSED = 1;
   */
  CLOSED = 1,

  /**
   * The session close request is in progress. The client may retry
   * the close request.
   *
   * @generated from enum value: CLOSING = 2;
   */
  CLOSING = 2,

  /**
   * The session is not closeable. The client should not retry the
   * close request.
   *
   * @generated from enum value: NOT_CLOSEABLE = 3;
   */
  NOT_CLOSEABLE = 3,
}

/**
 * Describes the enum arrow.flight.protocol.CloseSessionResult.Status.
 */
export const CloseSessionResult_StatusSchema: GenEnum<CloseSessionResult_Status> = /*@__PURE__*/
  enumDesc(file_Flight, 26, 0);

/**
 *
 * The result of a cancel operation.
 *
 * This is used by CancelFlightInfoResult.status.
 *
 * @generated from enum arrow.flight.protocol.CancelStatus
 */
export enum CancelStatus {
  /**
   * The cancellation status is unknown. Servers should avoid using
   * this value (send a NOT_FOUND error if the requested query is
   * not known). Clients can retry the request.
   *
   * @generated from enum value: CANCEL_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The cancellation request is complete. Subsequent requests with
   * the same payload may return CANCELLED or a NOT_FOUND error.
   *
   * @generated from enum value: CANCEL_STATUS_CANCELLED = 1;
   */
  CANCELLED = 1,

  /**
   * The cancellation request is in progress. The client may retry
   * the cancellation request.
   *
   * @generated from enum value: CANCEL_STATUS_CANCELLING = 2;
   */
  CANCELLING = 2,

  /**
   * The query is not cancellable. The client should not retry the
   * cancellation request.
   *
   * @generated from enum value: CANCEL_STATUS_NOT_CANCELLABLE = 3;
   */
  NOT_CANCELLABLE = 3,
}

/**
 * Describes the enum arrow.flight.protocol.CancelStatus.
 */
export const CancelStatusSchema: GenEnum<CancelStatus> = /*@__PURE__*/
  enumDesc(file_Flight, 0);

/**
 *
 * A flight service is an endpoint for retrieving or storing Arrow data. A
 * flight service can expose one or more predefined endpoints that can be
 * accessed using the Arrow Flight Protocol. Additionally, a flight service
 * can expose a set of actions that are available.
 *
 * @generated from service arrow.flight.protocol.FlightService
 */
export const FlightService: GenService<{
  /**
   *
   * Handshake between client and server. Depending on the server, the
   * handshake may be required to determine the token that should be used for
   * future operations. Both request and response are streams to allow multiple
   * round-trips depending on auth mechanism.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.Handshake
   */
  handshake: {
    methodKind: "bidi_streaming";
    input: typeof HandshakeRequestSchema;
    output: typeof HandshakeResponseSchema;
  },
  /**
   *
   * Get a list of available streams given a particular criteria. Most flight
   * services will expose one or more streams that are readily available for
   * retrieval. This api allows listing the streams available for
   * consumption. A user can also provide a criteria. The criteria can limit
   * the subset of streams that can be listed via this interface. Each flight
   * service allows its own definition of how to consume criteria.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.ListFlights
   */
  listFlights: {
    methodKind: "server_streaming";
    input: typeof CriteriaSchema;
    output: typeof FlightInfoSchema;
  },
  /**
   *
   * For a given FlightDescriptor, get information about how the flight can be
   * consumed. This is a useful interface if the consumer of the interface
   * already can identify the specific flight to consume. This interface can
   * also allow a consumer to generate a flight stream through a specified
   * descriptor. For example, a flight descriptor might be something that
   * includes a SQL statement or a Pickled Python operation that will be
   * executed. In those cases, the descriptor will not be previously available
   * within the list of available streams provided by ListFlights but will be
   * available for consumption for the duration defined by the specific flight
   * service.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.GetFlightInfo
   */
  getFlightInfo: {
    methodKind: "unary";
    input: typeof FlightDescriptorSchema;
    output: typeof FlightInfoSchema;
  },
  /**
   *
   * For a given FlightDescriptor, start a query and get information
   * to poll its execution status. This is a useful interface if the
   * query may be a long-running query. The first PollFlightInfo call
   * should return as quickly as possible. (GetFlightInfo doesn't
   * return until the query is complete.)
   *
   * A client can consume any available results before
   * the query is completed. See PollInfo.info for details.
   *
   * A client can poll the updated query status by calling
   * PollFlightInfo() with PollInfo.flight_descriptor. A server
   * should not respond until the result would be different from last
   * time. That way, the client can "long poll" for updates
   * without constantly making requests. Clients can set a short timeout
   * to avoid blocking calls if desired.
   *
   * A client can't use PollInfo.flight_descriptor after
   * PollInfo.expiration_time passes. A server might not accept the
   * retry descriptor anymore and the query may be cancelled.
   *
   * A client may use the CancelFlightInfo action with
   * PollInfo.info to cancel the running query.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.PollFlightInfo
   */
  pollFlightInfo: {
    methodKind: "unary";
    input: typeof FlightDescriptorSchema;
    output: typeof PollInfoSchema;
  },
  /**
   *
   * For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
   * This is used when a consumer needs the Schema of flight stream. Similar to
   * GetFlightInfo this interface may generate a new flight that was not previously
   * available in ListFlights.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.GetSchema
   */
  getSchema: {
    methodKind: "unary";
    input: typeof FlightDescriptorSchema;
    output: typeof SchemaResultSchema;
  },
  /**
   *
   * Retrieve a single stream associated with a particular descriptor
   * associated with the referenced ticket. A Flight can be composed of one or
   * more streams where each stream can be retrieved using a separate opaque
   * ticket that the flight service uses for managing a collection of streams.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoGet
   */
  doGet: {
    methodKind: "server_streaming";
    input: typeof TicketSchema;
    output: typeof FlightDataSchema;
  },
  /**
   *
   * Push a stream to the flight service associated with a particular
   * flight stream. This allows a client of a flight service to upload a stream
   * of data. Depending on the particular flight service, a client consumer
   * could be allowed to upload a single stream per descriptor or an unlimited
   * number. In the latter, the service might implement a 'seal' action that
   * can be applied to a descriptor once all streams are uploaded.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoPut
   */
  doPut: {
    methodKind: "bidi_streaming";
    input: typeof FlightDataSchema;
    output: typeof PutResultSchema;
  },
  /**
   *
   * Open a bidirectional data channel for a given descriptor. This
   * allows clients to send and receive arbitrary Arrow data and
   * application-specific metadata in a single logical stream. In
   * contrast to DoGet/DoPut, this is more suited for clients
   * offloading computation (rather than storage) to a Flight service.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoExchange
   */
  doExchange: {
    methodKind: "bidi_streaming";
    input: typeof FlightDataSchema;
    output: typeof FlightDataSchema;
  },
  /**
   *
   * Flight services can support an arbitrary number of simple actions in
   * addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
   * operations that are potentially available. DoAction allows a flight client
   * to do a specific action against a flight service. An action includes
   * opaque request and response objects that are specific to the type action
   * being undertaken.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.DoAction
   */
  doAction: {
    methodKind: "server_streaming";
    input: typeof ActionSchema;
    output: typeof ResultSchema;
  },
  /**
   *
   * A flight service exposes all of the available action types that it has
   * along with descriptions. This allows different flight consumers to
   * understand the capabilities of the flight service.
   *
   * @generated from rpc arrow.flight.protocol.FlightService.ListActions
   */
  listActions: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof ActionTypeSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_Flight, 0);

