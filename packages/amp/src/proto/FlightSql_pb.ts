//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
// <p>
// http://www.apache.org/licenses/LICENSE-2.0
// <p>
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.10.1 with parameter "target=ts,import_extension=ts"
// @generated from file FlightSql.proto (package arrow.flight.protocol.sql, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenExtension, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, extDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { MessageOptions } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_descriptor } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file FlightSql.proto.
 */
export const file_FlightSql: GenFile = /*@__PURE__*/
  fileDesc("Cg9GbGlnaHRTcWwucHJvdG8SGWFycm93LmZsaWdodC5wcm90b2NvbC5zcWwiIQoRQ29tbWFuZEdldFNxbEluZm8SDAoEaW5mbxgBIAMoDSI+ChZDb21tYW5kR2V0WGRiY1R5cGVJbmZvEhYKCWRhdGFfdHlwZRgBIAEoBUgAiAEBQgwKCl9kYXRhX3R5cGUiFAoSQ29tbWFuZEdldENhdGFsb2dzInsKE0NvbW1hbmRHZXREYlNjaGVtYXMSFAoHY2F0YWxvZxgBIAEoCUgAiAEBEiUKGGRiX3NjaGVtYV9maWx0ZXJfcGF0dGVybhgCIAEoCUgBiAEBQgoKCF9jYXRhbG9nQhsKGV9kYl9zY2hlbWFfZmlsdGVyX3BhdHRlcm4i6wEKEENvbW1hbmRHZXRUYWJsZXMSFAoHY2F0YWxvZxgBIAEoCUgAiAEBEiUKGGRiX3NjaGVtYV9maWx0ZXJfcGF0dGVybhgCIAEoCUgBiAEBEiYKGXRhYmxlX25hbWVfZmlsdGVyX3BhdHRlcm4YAyABKAlIAogBARITCgt0YWJsZV90eXBlcxgEIAMoCRIWCg5pbmNsdWRlX3NjaGVtYRgFIAEoCEIKCghfY2F0YWxvZ0IbChlfZGJfc2NoZW1hX2ZpbHRlcl9wYXR0ZXJuQhwKGl90YWJsZV9uYW1lX2ZpbHRlcl9wYXR0ZXJuIhYKFENvbW1hbmRHZXRUYWJsZVR5cGVzIm4KFUNvbW1hbmRHZXRQcmltYXJ5S2V5cxIUCgdjYXRhbG9nGAEgASgJSACIAQESFgoJZGJfc2NoZW1hGAIgASgJSAGIAQESDQoFdGFibGUYAyABKAlCCgoIX2NhdGFsb2dCDAoKX2RiX3NjaGVtYSJvChZDb21tYW5kR2V0RXhwb3J0ZWRLZXlzEhQKB2NhdGFsb2cYASABKAlIAIgBARIWCglkYl9zY2hlbWEYAiABKAlIAYgBARINCgV0YWJsZRgDIAEoCUIKCghfY2F0YWxvZ0IMCgpfZGJfc2NoZW1hIm8KFkNvbW1hbmRHZXRJbXBvcnRlZEtleXMSFAoHY2F0YWxvZxgBIAEoCUgAiAEBEhYKCWRiX3NjaGVtYRgCIAEoCUgBiAEBEg0KBXRhYmxlGAMgASgJQgoKCF9jYXRhbG9nQgwKCl9kYl9zY2hlbWEi5gEKGENvbW1hbmRHZXRDcm9zc1JlZmVyZW5jZRIXCgpwa19jYXRhbG9nGAEgASgJSACIAQESGQoMcGtfZGJfc2NoZW1hGAIgASgJSAGIAQESEAoIcGtfdGFibGUYAyABKAkSFwoKZmtfY2F0YWxvZxgEIAEoCUgCiAEBEhkKDGZrX2RiX3NjaGVtYRgFIAEoCUgDiAEBEhAKCGZrX3RhYmxlGAYgASgJQg0KC19wa19jYXRhbG9nQg8KDV9wa19kYl9zY2hlbWFCDQoLX2ZrX2NhdGFsb2dCDwoNX2ZrX2RiX3NjaGVtYSJlCiRBY3Rpb25DcmVhdGVQcmVwYXJlZFN0YXRlbWVudFJlcXVlc3QSDQoFcXVlcnkYASABKAkSGwoOdHJhbnNhY3Rpb25faWQYAiABKAxIAIgBAUIRCg9fdHJhbnNhY3Rpb25faWQiLgoNU3Vic3RyYWl0UGxhbhIMCgRwbGFuGAEgASgMEg8KB3ZlcnNpb24YAiABKAkikgEKKEFjdGlvbkNyZWF0ZVByZXBhcmVkU3Vic3RyYWl0UGxhblJlcXVlc3QSNgoEcGxhbhgBIAEoCzIoLmFycm93LmZsaWdodC5wcm90b2NvbC5zcWwuU3Vic3RyYWl0UGxhbhIbCg50cmFuc2FjdGlvbl9pZBgCIAEoDEgAiAEBQhEKD190cmFuc2FjdGlvbl9pZCJ6CiNBY3Rpb25DcmVhdGVQcmVwYXJlZFN0YXRlbWVudFJlc3VsdBIhChlwcmVwYXJlZF9zdGF0ZW1lbnRfaGFuZGxlGAEgASgMEhYKDmRhdGFzZXRfc2NoZW1hGAIgASgMEhgKEHBhcmFtZXRlcl9zY2hlbWEYAyABKAwiSAojQWN0aW9uQ2xvc2VQcmVwYXJlZFN0YXRlbWVudFJlcXVlc3QSIQoZcHJlcGFyZWRfc3RhdGVtZW50X2hhbmRsZRgBIAEoDCIfCh1BY3Rpb25CZWdpblRyYW5zYWN0aW9uUmVxdWVzdCJDChtBY3Rpb25CZWdpblNhdmVwb2ludFJlcXVlc3QSFgoOdHJhbnNhY3Rpb25faWQYASABKAwSDAoEbmFtZRgCIAEoCSI2ChxBY3Rpb25CZWdpblRyYW5zYWN0aW9uUmVzdWx0EhYKDnRyYW5zYWN0aW9uX2lkGAEgASgMIjIKGkFjdGlvbkJlZ2luU2F2ZXBvaW50UmVzdWx0EhQKDHNhdmVwb2ludF9pZBgBIAEoDCL5AQobQWN0aW9uRW5kVHJhbnNhY3Rpb25SZXF1ZXN0EhYKDnRyYW5zYWN0aW9uX2lkGAEgASgMElUKBmFjdGlvbhgCIAEoDjJFLmFycm93LmZsaWdodC5wcm90b2NvbC5zcWwuQWN0aW9uRW5kVHJhbnNhY3Rpb25SZXF1ZXN0LkVuZFRyYW5zYWN0aW9uImsKDkVuZFRyYW5zYWN0aW9uEh8KG0VORF9UUkFOU0FDVElPTl9VTlNQRUNJRklFRBAAEhoKFkVORF9UUkFOU0FDVElPTl9DT01NSVQQARIcChhFTkRfVFJBTlNBQ1RJT05fUk9MTEJBQ0sQAiLqAQoZQWN0aW9uRW5kU2F2ZXBvaW50UmVxdWVzdBIUCgxzYXZlcG9pbnRfaWQYASABKAwSUQoGYWN0aW9uGAIgASgOMkEuYXJyb3cuZmxpZ2h0LnByb3RvY29sLnNxbC5BY3Rpb25FbmRTYXZlcG9pbnRSZXF1ZXN0LkVuZFNhdmVwb2ludCJkCgxFbmRTYXZlcG9pbnQSHQoZRU5EX1NBVkVQT0lOVF9VTlNQRUNJRklFRBAAEhkKFUVORF9TQVZFUE9JTlRfUkVMRUFTRRABEhoKFkVORF9TQVZFUE9JTlRfUk9MTEJBQ0sQAiJWChVDb21tYW5kU3RhdGVtZW50UXVlcnkSDQoFcXVlcnkYASABKAkSGwoOdHJhbnNhY3Rpb25faWQYAiABKAxIAIgBAUIRCg9fdHJhbnNhY3Rpb25faWQihwEKHUNvbW1hbmRTdGF0ZW1lbnRTdWJzdHJhaXRQbGFuEjYKBHBsYW4YASABKAsyKC5hcnJvdy5mbGlnaHQucHJvdG9jb2wuc3FsLlN1YnN0cmFpdFBsYW4SGwoOdHJhbnNhY3Rpb25faWQYAiABKAxIAIgBAUIRCg9fdHJhbnNhY3Rpb25faWQiMAoUVGlja2V0U3RhdGVtZW50UXVlcnkSGAoQc3RhdGVtZW50X2hhbmRsZRgBIAEoDCJCCh1Db21tYW5kUHJlcGFyZWRTdGF0ZW1lbnRRdWVyeRIhChlwcmVwYXJlZF9zdGF0ZW1lbnRfaGFuZGxlGAEgASgMIlcKFkNvbW1hbmRTdGF0ZW1lbnRVcGRhdGUSDQoFcXVlcnkYASABKAkSGwoOdHJhbnNhY3Rpb25faWQYAiABKAxIAIgBAUIRCg9fdHJhbnNhY3Rpb25faWQiQwoeQ29tbWFuZFByZXBhcmVkU3RhdGVtZW50VXBkYXRlEiEKGXByZXBhcmVkX3N0YXRlbWVudF9oYW5kbGUYASABKAwitgcKFkNvbW1hbmRTdGF0ZW1lbnRJbmdlc3QSagoYdGFibGVfZGVmaW5pdGlvbl9vcHRpb25zGAEgASgLMkguYXJyb3cuZmxpZ2h0LnByb3RvY29sLnNxbC5Db21tYW5kU3RhdGVtZW50SW5nZXN0LlRhYmxlRGVmaW5pdGlvbk9wdGlvbnMSDQoFdGFibGUYAiABKAkSEwoGc2NoZW1hGAMgASgJSACIAQESFAoHY2F0YWxvZxgEIAEoCUgBiAEBEhEKCXRlbXBvcmFyeRgFIAEoCBIbCg50cmFuc2FjdGlvbl9pZBgGIAEoDEgCiAEBElAKB29wdGlvbnMY6AcgAygLMj4uYXJyb3cuZmxpZ2h0LnByb3RvY29sLnNxbC5Db21tYW5kU3RhdGVtZW50SW5nZXN0Lk9wdGlvbnNFbnRyeRqZBAoWVGFibGVEZWZpbml0aW9uT3B0aW9ucxJyCgxpZl9ub3RfZXhpc3QYASABKA4yXC5hcnJvdy5mbGlnaHQucHJvdG9jb2wuc3FsLkNvbW1hbmRTdGF0ZW1lbnRJbmdlc3QuVGFibGVEZWZpbml0aW9uT3B0aW9ucy5UYWJsZU5vdEV4aXN0T3B0aW9uEm0KCWlmX2V4aXN0cxgCIAEoDjJaLmFycm93LmZsaWdodC5wcm90b2NvbC5zcWwuQ29tbWFuZFN0YXRlbWVudEluZ2VzdC5UYWJsZURlZmluaXRpb25PcHRpb25zLlRhYmxlRXhpc3RzT3B0aW9uIoEBChNUYWJsZU5vdEV4aXN0T3B0aW9uEiYKIlRBQkxFX05PVF9FWElTVF9PUFRJT05fVU5TUEVDSUZJRUQQABIhCh1UQUJMRV9OT1RfRVhJU1RfT1BUSU9OX0NSRUFURRABEh8KG1RBQkxFX05PVF9FWElTVF9PUFRJT05fRkFJTBACIpcBChFUYWJsZUV4aXN0c09wdGlvbhIjCh9UQUJMRV9FWElTVFNfT1BUSU9OX1VOU1BFQ0lGSUVEEAASHAoYVEFCTEVfRVhJU1RTX09QVElPTl9GQUlMEAESHgoaVEFCTEVfRVhJU1RTX09QVElPTl9BUFBFTkQQAhIfChtUQUJMRV9FWElTVFNfT1BUSU9OX1JFUExBQ0UQAxouCgxPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4AUIJCgdfc2NoZW1hQgoKCF9jYXRhbG9nQhEKD190cmFuc2FjdGlvbl9pZCIpChFEb1B1dFVwZGF0ZVJlc3VsdBIUCgxyZWNvcmRfY291bnQYASABKAMiZAocRG9QdXRQcmVwYXJlZFN0YXRlbWVudFJlc3VsdBImChlwcmVwYXJlZF9zdGF0ZW1lbnRfaGFuZGxlGAEgASgMSACIAQFCHAoaX3ByZXBhcmVkX3N0YXRlbWVudF9oYW5kbGUiLAoYQWN0aW9uQ2FuY2VsUXVlcnlSZXF1ZXN0EgwKBGluZm8YASABKAw6AhgBIvwBChdBY3Rpb25DYW5jZWxRdWVyeVJlc3VsdBJPCgZyZXN1bHQYASABKA4yPy5hcnJvdy5mbGlnaHQucHJvdG9jb2wuc3FsLkFjdGlvbkNhbmNlbFF1ZXJ5UmVzdWx0LkNhbmNlbFJlc3VsdCKLAQoMQ2FuY2VsUmVzdWx0Eh0KGUNBTkNFTF9SRVNVTFRfVU5TUEVDSUZJRUQQABIbChdDQU5DRUxfUkVTVUxUX0NBTkNFTExFRBABEhwKGENBTkNFTF9SRVNVTFRfQ0FOQ0VMTElORxACEiEKHUNBTkNFTF9SRVNVTFRfTk9UX0NBTkNFTExBQkxFEAM6AhgBKpIZCgdTcWxJbmZvEhoKFkZMSUdIVF9TUUxfU0VSVkVSX05BTUUQABIdChlGTElHSFRfU1FMX1NFUlZFUl9WRVJTSU9OEAESIwofRkxJR0hUX1NRTF9TRVJWRVJfQVJST1dfVkVSU0lPThACEh8KG0ZMSUdIVF9TUUxfU0VSVkVSX1JFQURfT05MWRADEhkKFUZMSUdIVF9TUUxfU0VSVkVSX1NRTBAEEh8KG0ZMSUdIVF9TUUxfU0VSVkVSX1NVQlNUUkFJVBAFEisKJ0ZMSUdIVF9TUUxfU0VSVkVSX1NVQlNUUkFJVF9NSU5fVkVSU0lPThAGEisKJ0ZMSUdIVF9TUUxfU0VSVkVSX1NVQlNUUkFJVF9NQVhfVkVSU0lPThAHEiEKHUZMSUdIVF9TUUxfU0VSVkVSX1RSQU5TQUNUSU9OEAgSHAoYRkxJR0hUX1NRTF9TRVJWRVJfQ0FOQ0VMEAkSJAogRkxJR0hUX1NRTF9TRVJWRVJfQlVMS19JTkdFU1RJT04QChIzCi9GTElHSFRfU1FMX1NFUlZFUl9JTkdFU1RfVFJBTlNBQ1RJT05TX1NVUFBPUlRFRBALEicKI0ZMSUdIVF9TUUxfU0VSVkVSX1NUQVRFTUVOVF9USU1FT1VUEGQSKQolRkxJR0hUX1NRTF9TRVJWRVJfVFJBTlNBQ1RJT05fVElNRU9VVBBlEhQKD1NRTF9ERExfQ0FUQUxPRxD0AxITCg5TUUxfRERMX1NDSEVNQRD1AxISCg1TUUxfRERMX1RBQkxFEPYDEhgKE1NRTF9JREVOVElGSUVSX0NBU0UQ9wMSHgoZU1FMX0lERU5USUZJRVJfUVVPVEVfQ0hBUhD4AxIfChpTUUxfUVVPVEVEX0lERU5USUZJRVJfQ0FTRRD5AxIiCh1TUUxfQUxMX1RBQkxFU19BUkVfU0VMRUNUQUJMRRD6AxIWChFTUUxfTlVMTF9PUkRFUklORxD7AxIRCgxTUUxfS0VZV09SRFMQ/AMSGgoVU1FMX05VTUVSSUNfRlVOQ1RJT05TEP0DEhkKFFNRTF9TVFJJTkdfRlVOQ1RJT05TEP4DEhkKFFNRTF9TWVNURU1fRlVOQ1RJT05TEP8DEhsKFlNRTF9EQVRFVElNRV9GVU5DVElPTlMQgAQSHQoYU1FMX1NFQVJDSF9TVFJJTkdfRVNDQVBFEIEEEh4KGVNRTF9FWFRSQV9OQU1FX0NIQVJBQ1RFUlMQggQSIQocU1FMX1NVUFBPUlRTX0NPTFVNTl9BTElBU0lORxCDBBIfChpTUUxfTlVMTF9QTFVTX05VTExfSVNfTlVMTBCEBBIZChRTUUxfU1VQUE9SVFNfQ09OVkVSVBCFBBIpCiRTUUxfU1VQUE9SVFNfVEFCTEVfQ09SUkVMQVRJT05fTkFNRVMQhgQSMwouU1FMX1NVUFBPUlRTX0RJRkZFUkVOVF9UQUJMRV9DT1JSRUxBVElPTl9OQU1FUxCHBBIpCiRTUUxfU1VQUE9SVFNfRVhQUkVTU0lPTlNfSU5fT1JERVJfQlkQiAQSJAofU1FMX1NVUFBPUlRTX09SREVSX0JZX1VOUkVMQVRFRBCJBBIbChZTUUxfU1VQUE9SVEVEX0dST1VQX0JZEIoEEiQKH1NRTF9TVVBQT1JUU19MSUtFX0VTQ0FQRV9DTEFVU0UQiwQSJgohU1FMX1NVUFBPUlRTX05PTl9OVUxMQUJMRV9DT0xVTU5TEIwEEhoKFVNRTF9TVVBQT1JURURfR1JBTU1BUhCNBBIfChpTUUxfQU5TSTkyX1NVUFBPUlRFRF9MRVZFTBCOBBIwCitTUUxfU1VQUE9SVFNfSU5URUdSSVRZX0VOSEFOQ0VNRU5UX0ZBQ0lMSVRZEI8EEiIKHVNRTF9PVVRFUl9KT0lOU19TVVBQT1JUX0xFVkVMEJAEEhQKD1NRTF9TQ0hFTUFfVEVSTRCRBBIXChJTUUxfUFJPQ0VEVVJFX1RFUk0QkgQSFQoQU1FMX0NBVEFMT0dfVEVSTRCTBBIZChRTUUxfQ0FUQUxPR19BVF9TVEFSVBCUBBIiCh1TUUxfU0NIRU1BU19TVVBQT1JURURfQUNUSU9OUxCVBBIjCh5TUUxfQ0FUQUxPR1NfU1VQUE9SVEVEX0FDVElPTlMQlgQSJgohU1FMX1NVUFBPUlRFRF9QT1NJVElPTkVEX0NPTU1BTkRTEJcEEiQKH1NRTF9TRUxFQ1RfRk9SX1VQREFURV9TVVBQT1JURUQQmAQSJAofU1FMX1NUT1JFRF9QUk9DRURVUkVTX1NVUFBPUlRFRBCZBBIdChhTUUxfU1VQUE9SVEVEX1NVQlFVRVJJRVMQmgQSKAojU1FMX0NPUlJFTEFURURfU1VCUVVFUklFU19TVVBQT1JURUQQmwQSGQoUU1FMX1NVUFBPUlRFRF9VTklPTlMQnAQSIgodU1FMX01BWF9CSU5BUllfTElURVJBTF9MRU5HVEgQnQQSIAobU1FMX01BWF9DSEFSX0xJVEVSQUxfTEVOR1RIEJ4EEh8KGlNRTF9NQVhfQ09MVU1OX05BTUVfTEVOR1RIEJ8EEiAKG1NRTF9NQVhfQ09MVU1OU19JTl9HUk9VUF9CWRCgBBIdChhTUUxfTUFYX0NPTFVNTlNfSU5fSU5ERVgQoQQSIAobU1FMX01BWF9DT0xVTU5TX0lOX09SREVSX0JZEKIEEh4KGVNRTF9NQVhfQ09MVU1OU19JTl9TRUxFQ1QQowQSHQoYU1FMX01BWF9DT0xVTU5TX0lOX1RBQkxFEKQEEhgKE1NRTF9NQVhfQ09OTkVDVElPTlMQpQQSHwoaU1FMX01BWF9DVVJTT1JfTkFNRV9MRU5HVEgQpgQSGQoUU1FMX01BWF9JTkRFWF9MRU5HVEgQpwQSHgoZU1FMX0RCX1NDSEVNQV9OQU1FX0xFTkdUSBCoBBIiCh1TUUxfTUFYX1BST0NFRFVSRV9OQU1FX0xFTkdUSBCpBBIgChtTUUxfTUFYX0NBVEFMT0dfTkFNRV9MRU5HVEgQqgQSFQoQU1FMX01BWF9ST1dfU0laRRCrBBIkCh9TUUxfTUFYX1JPV19TSVpFX0lOQ0xVREVTX0JMT0JTEKwEEh0KGFNRTF9NQVhfU1RBVEVNRU5UX0xFTkdUSBCtBBIXChJTUUxfTUFYX1NUQVRFTUVOVFMQrgQSHgoZU1FMX01BWF9UQUJMRV9OQU1FX0xFTkdUSBCvBBIdChhTUUxfTUFYX1RBQkxFU19JTl9TRUxFQ1QQsAQSHAoXU1FMX01BWF9VU0VSTkFNRV9MRU5HVEgQsQQSJgohU1FMX0RFRkFVTFRfVFJBTlNBQ1RJT05fSVNPTEFUSU9OELIEEh8KGlNRTF9UUkFOU0FDVElPTlNfU1VQUE9SVEVEELMEEjAKK1NRTF9TVVBQT1JURURfVFJBTlNBQ1RJT05TX0lTT0xBVElPTl9MRVZFTFMQtAQSMgotU1FMX0RBVEFfREVGSU5JVElPTl9DQVVTRVNfVFJBTlNBQ1RJT05fQ09NTUlUELUEEjEKLFNRTF9EQVRBX0RFRklOSVRJT05TX0lOX1RSQU5TQUNUSU9OU19JR05PUkVEELYEEiMKHlNRTF9TVVBQT1JURURfUkVTVUxUX1NFVF9UWVBFUxC3BBI7CjZTUUxfU1VQUE9SVEVEX0NPTkNVUlJFTkNJRVNfRk9SX1JFU1VMVF9TRVRfVU5TUEVDSUZJRUQQuAQSPAo3U1FMX1NVUFBPUlRFRF9DT05DVVJSRU5DSUVTX0ZPUl9SRVNVTFRfU0VUX0ZPUldBUkRfT05MWRC5BBJACjtTUUxfU1VQUE9SVEVEX0NPTkNVUlJFTkNJRVNfRk9SX1JFU1VMVF9TRVRfU0NST0xMX1NFTlNJVElWRRC6BBJCCj1TUUxfU1VQUE9SVEVEX0NPTkNVUlJFTkNJRVNfRk9SX1JFU1VMVF9TRVRfU0NST0xMX0lOU0VOU0lUSVZFELsEEiAKG1NRTF9CQVRDSF9VUERBVEVTX1NVUFBPUlRFRBC8BBIdChhTUUxfU0FWRVBPSU5UU19TVVBQT1JURUQQvQQSIwoeU1FMX05BTUVEX1BBUkFNRVRFUlNfU1VQUE9SVEVEEL4EEh0KGFNRTF9MT0NBVE9SU19VUERBVEVfQ09QWRC/BBI1CjBTUUxfU1RPUkVEX0ZVTkNUSU9OU19VU0lOR19DQUxMX1NZTlRBWF9TVVBQT1JURUQQwAQqkQEKF1NxbFN1cHBvcnRlZFRyYW5zYWN0aW9uEiIKHlNRTF9TVVBQT1JURURfVFJBTlNBQ1RJT05fTk9ORRAAEikKJVNRTF9TVVBQT1JURURfVFJBTlNBQ1RJT05fVFJBTlNBQ1RJT04QARInCiNTUUxfU1VQUE9SVEVEX1RSQU5TQUNUSU9OX1NBVkVQT0lOVBACKrIBChtTcWxTdXBwb3J0ZWRDYXNlU2Vuc2l0aXZpdHkSIAocU1FMX0NBU0VfU0VOU0lUSVZJVFlfVU5LTk9XThAAEikKJVNRTF9DQVNFX1NFTlNJVElWSVRZX0NBU0VfSU5TRU5TSVRJVkUQARIiCh5TUUxfQ0FTRV9TRU5TSVRJVklUWV9VUFBFUkNBU0UQAhIiCh5TUUxfQ0FTRV9TRU5TSVRJVklUWV9MT1dFUkNBU0UQAyqCAQoPU3FsTnVsbE9yZGVyaW5nEhkKFVNRTF9OVUxMU19TT1JURURfSElHSBAAEhgKFFNRTF9OVUxMU19TT1JURURfTE9XEAESHQoZU1FMX05VTExTX1NPUlRFRF9BVF9TVEFSVBACEhsKF1NRTF9OVUxMU19TT1JURURfQVRfRU5EEAMqXgoTU3VwcG9ydGVkU3FsR3JhbW1hchIXChNTUUxfTUlOSU1VTV9HUkFNTUFSEAASFAoQU1FMX0NPUkVfR1JBTU1BUhABEhgKFFNRTF9FWFRFTkRFRF9HUkFNTUFSEAIqaAoeU3VwcG9ydGVkQW5zaTkyU3FsR3JhbW1hckxldmVsEhQKEEFOU0k5Ml9FTlRSWV9TUUwQABIbChdBTlNJOTJfSU5URVJNRURJQVRFX1NRTBABEhMKD0FOU0k5Ml9GVUxMX1NRTBACKm0KGVNxbE91dGVySm9pbnNTdXBwb3J0TGV2ZWwSGQoVU1FMX0pPSU5TX1VOU1VQUE9SVEVEEAASGwoXU1FMX0xJTUlURURfT1VURVJfSk9JTlMQARIYChRTUUxfRlVMTF9PVVRFUl9KT0lOUxACKlEKE1NxbFN1cHBvcnRlZEdyb3VwQnkSGgoWU1FMX0dST1VQX0JZX1VOUkVMQVRFRBAAEh4KGlNRTF9HUk9VUF9CWV9CRVlPTkRfU0VMRUNUEAEqkAEKGlNxbFN1cHBvcnRlZEVsZW1lbnRBY3Rpb25zEiIKHlNRTF9FTEVNRU5UX0lOX1BST0NFRFVSRV9DQUxMUxAAEiQKIFNRTF9FTEVNRU5UX0lOX0lOREVYX0RFRklOSVRJT05TEAESKAokU1FMX0VMRU1FTlRfSU5fUFJJVklMRUdFX0RFRklOSVRJT05TEAIqVgoeU3FsU3VwcG9ydGVkUG9zaXRpb25lZENvbW1hbmRzEhkKFVNRTF9QT1NJVElPTkVEX0RFTEVURRAAEhkKFVNRTF9QT1NJVElPTkVEX1VQREFURRABKpcBChZTcWxTdXBwb3J0ZWRTdWJxdWVyaWVzEiEKHVNRTF9TVUJRVUVSSUVTX0lOX0NPTVBBUklTT05TEAASHAoYU1FMX1NVQlFVRVJJRVNfSU5fRVhJU1RTEAESGQoVU1FMX1NVQlFVRVJJRVNfSU5fSU5TEAISIQodU1FMX1NVQlFVRVJJRVNfSU5fUVVBTlRJRklFRFMQAyo2ChJTcWxTdXBwb3J0ZWRVbmlvbnMSDQoJU1FMX1VOSU9OEAASEQoNU1FMX1VOSU9OX0FMTBABKskBChxTcWxUcmFuc2FjdGlvbklzb2xhdGlvbkxldmVsEhgKFFNRTF9UUkFOU0FDVElPTl9OT05FEAASJAogU1FMX1RSQU5TQUNUSU9OX1JFQURfVU5DT01NSVRURUQQARIiCh5TUUxfVFJBTlNBQ1RJT05fUkVBRF9DT01NSVRURUQQAhIjCh9TUUxfVFJBTlNBQ1RJT05fUkVQRUFUQUJMRV9SRUFEEAMSIAocU1FMX1RSQU5TQUNUSU9OX1NFUklBTElaQUJMRRAEKokBChhTcWxTdXBwb3J0ZWRUcmFuc2FjdGlvbnMSHwobU1FMX1RSQU5TQUNUSU9OX1VOU1BFQ0lGSUVEEAASJAogU1FMX0RBVEFfREVGSU5JVElPTl9UUkFOU0FDVElPTlMQARImCiJTUUxfREFUQV9NQU5JUFVMQVRJT05fVFJBTlNBQ1RJT05TEAIqvAEKGVNxbFN1cHBvcnRlZFJlc3VsdFNldFR5cGUSIwofU1FMX1JFU1VMVF9TRVRfVFlQRV9VTlNQRUNJRklFRBAAEiQKIFNRTF9SRVNVTFRfU0VUX1RZUEVfRk9SV0FSRF9PTkxZEAESKgomU1FMX1JFU1VMVF9TRVRfVFlQRV9TQ1JPTExfSU5TRU5TSVRJVkUQAhIoCiRTUUxfUkVTVUxUX1NFVF9UWVBFX1NDUk9MTF9TRU5TSVRJVkUQAyqiAQogU3FsU3VwcG9ydGVkUmVzdWx0U2V0Q29uY3VycmVuY3kSKgomU1FMX1JFU1VMVF9TRVRfQ09OQ1VSUkVOQ1lfVU5TUEVDSUZJRUQQABIoCiRTUUxfUkVTVUxUX1NFVF9DT05DVVJSRU5DWV9SRUFEX09OTFkQARIoCiRTUUxfUkVTVUxUX1NFVF9DT05DVVJSRU5DWV9VUERBVEFCTEUQAiqZBAoSU3FsU3VwcG9ydHNDb252ZXJ0EhYKElNRTF9DT05WRVJUX0JJR0lOVBAAEhYKElNRTF9DT05WRVJUX0JJTkFSWRABEhMKD1NRTF9DT05WRVJUX0JJVBACEhQKEFNRTF9DT05WRVJUX0NIQVIQAxIUChBTUUxfQ09OVkVSVF9EQVRFEAQSFwoTU1FMX0NPTlZFUlRfREVDSU1BTBAFEhUKEVNRTF9DT05WRVJUX0ZMT0FUEAYSFwoTU1FMX0NPTlZFUlRfSU5URUdFUhAHEiEKHVNRTF9DT05WRVJUX0lOVEVSVkFMX0RBWV9USU1FEAgSIwofU1FMX0NPTlZFUlRfSU5URVJWQUxfWUVBUl9NT05USBAJEh0KGVNRTF9DT05WRVJUX0xPTkdWQVJCSU5BUlkQChIbChdTUUxfQ09OVkVSVF9MT05HVkFSQ0hBUhALEhcKE1NRTF9DT05WRVJUX05VTUVSSUMQDBIUChBTUUxfQ09OVkVSVF9SRUFMEA0SGAoUU1FMX0NPTlZFUlRfU01BTExJTlQQDhIUChBTUUxfQ09OVkVSVF9USU1FEA8SGQoVU1FMX0NPTlZFUlRfVElNRVNUQU1QEBASFwoTU1FMX0NPTlZFUlRfVElOWUlOVBAREhkKFVNRTF9DT05WRVJUX1ZBUkJJTkFSWRASEhcKE1NRTF9DT05WRVJUX1ZBUkNIQVIQEyqPBAoMWGRiY0RhdGFUeXBlEhUKEVhEQkNfVU5LTk9XTl9UWVBFEAASDQoJWERCQ19DSEFSEAESEAoMWERCQ19OVU1FUklDEAISEAoMWERCQ19ERUNJTUFMEAMSEAoMWERCQ19JTlRFR0VSEAQSEQoNWERCQ19TTUFMTElOVBAFEg4KClhEQkNfRkxPQVQQBhINCglYREJDX1JFQUwQBxIPCgtYREJDX0RPVUJMRRAIEhEKDVhEQkNfREFURVRJTUUQCRIRCg1YREJDX0lOVEVSVkFMEAoSEAoMWERCQ19WQVJDSEFSEAwSDQoJWERCQ19EQVRFEFsSDQoJWERCQ19USU1FEFwSEgoOWERCQ19USU1FU1RBTVAQXRIdChBYREJDX0xPTkdWQVJDSEFSEP///////////wESGAoLWERCQ19CSU5BUlkQ/v//////////ARIbCg5YREJDX1ZBUkJJTkFSWRD9//////////8BEh8KElhEQkNfTE9OR1ZBUkJJTkFSWRD8//////////8BEhgKC1hEQkNfQklHSU5UEPv//////////wESGQoMWERCQ19USU5ZSU5UEPr//////////wESFQoIWERCQ19CSVQQ+f//////////ARIXCgpYREJDX1dDSEFSEPj//////////wESGgoNWERCQ19XVkFSQ0hBUhD3//////////8BKqMIChNYZGJjRGF0ZXRpbWVTdWJjb2RlEhgKFFhEQkNfU1VCQ09ERV9VTktOT1dOEAASFQoRWERCQ19TVUJDT0RFX1lFQVIQARIVChFYREJDX1NVQkNPREVfREFURRABEhUKEVhEQkNfU1VCQ09ERV9USU1FEAISFgoSWERCQ19TVUJDT0RFX01PTlRIEAISGgoWWERCQ19TVUJDT0RFX1RJTUVTVEFNUBADEhQKEFhEQkNfU1VCQ09ERV9EQVkQAxIjCh9YREJDX1NVQkNPREVfVElNRV9XSVRIX1RJTUVaT05FEAQSFQoRWERCQ19TVUJDT0RFX0hPVVIQBBIoCiRYREJDX1NVQkNPREVfVElNRVNUQU1QX1dJVEhfVElNRVpPTkUQBRIXChNYREJDX1NVQkNPREVfTUlOVVRFEAUSFwoTWERCQ19TVUJDT0RFX1NFQ09ORBAGEh4KGlhEQkNfU1VCQ09ERV9ZRUFSX1RPX01PTlRIEAcSHAoYWERCQ19TVUJDT0RFX0RBWV9UT19IT1VSEAgSHgoaWERCQ19TVUJDT0RFX0RBWV9UT19NSU5VVEUQCRIeChpYREJDX1NVQkNPREVfREFZX1RPX1NFQ09ORBAKEh8KG1hEQkNfU1VCQ09ERV9IT1VSX1RPX01JTlVURRALEh8KG1hEQkNfU1VCQ09ERV9IT1VSX1RPX1NFQ09ORBAMEiEKHVhEQkNfU1VCQ09ERV9NSU5VVEVfVE9fU0VDT05EEA0SHgoaWERCQ19TVUJDT0RFX0lOVEVSVkFMX1lFQVIQZRIfChtYREJDX1NVQkNPREVfSU5URVJWQUxfTU9OVEgQZhIdChlYREJDX1NVQkNPREVfSU5URVJWQUxfREFZEGcSHgoaWERCQ19TVUJDT0RFX0lOVEVSVkFMX0hPVVIQaBIgChxYREJDX1NVQkNPREVfSU5URVJWQUxfTUlOVVRFEGkSIAocWERCQ19TVUJDT0RFX0lOVEVSVkFMX1NFQ09ORBBqEicKI1hEQkNfU1VCQ09ERV9JTlRFUlZBTF9ZRUFSX1RPX01PTlRIEGsSJQohWERCQ19TVUJDT0RFX0lOVEVSVkFMX0RBWV9UT19IT1VSEGwSJwojWERCQ19TVUJDT0RFX0lOVEVSVkFMX0RBWV9UT19NSU5VVEUQbRInCiNYREJDX1NVQkNPREVfSU5URVJWQUxfREFZX1RPX1NFQ09ORBBuEigKJFhEQkNfU1VCQ09ERV9JTlRFUlZBTF9IT1VSX1RPX01JTlVURRBvEigKJFhEQkNfU1VCQ09ERV9JTlRFUlZBTF9IT1VSX1RPX1NFQ09ORBBwEioKJlhEQkNfU1VCQ09ERV9JTlRFUlZBTF9NSU5VVEVfVE9fU0VDT05EEHEaAhABKlcKCE51bGxhYmxlEhgKFE5VTExBQklMSVRZX05PX05VTExTEAASGAoUTlVMTEFCSUxJVFlfTlVMTEFCTEUQARIXChNOVUxMQUJJTElUWV9VTktOT1dOEAIqYQoKU2VhcmNoYWJsZRITCg9TRUFSQ0hBQkxFX05PTkUQABITCg9TRUFSQ0hBQkxFX0NIQVIQARIUChBTRUFSQ0hBQkxFX0JBU0lDEAISEwoPU0VBUkNIQUJMRV9GVUxMEAMqXAoRVXBkYXRlRGVsZXRlUnVsZXMSCwoHQ0FTQ0FERRAAEgwKCFJFU1RSSUNUEAESDAoIU0VUX05VTEwQAhINCglOT19BQ1RJT04QAxIPCgtTRVRfREVGQVVMVBAEOkQKDGV4cGVyaW1lbnRhbBIfLmdvb2dsZS5wcm90b2J1Zi5NZXNzYWdlT3B0aW9ucxjoByABKAhSDGV4cGVyaW1lbnRhbEJWCiBvcmcuYXBhY2hlLmFycm93LmZsaWdodC5zcWwuaW1wbFoyZ2l0aHViLmNvbS9hcGFjaGUvYXJyb3ctZ28vYXJyb3cvZmxpZ2h0L2dlbi9mbGlnaHRiBnByb3RvMw", [file_google_protobuf_descriptor]);

/**
 *
 * Represents a metadata request. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  info_name: uint32 not null,
 *  value: dense_union<
 *              string_value: utf8,
 *              bool_value: bool,
 *              bigint_value: int64,
 *              int32_bitmask: int32,
 *              string_list: list<string_data: utf8>
 *              int32_to_int32_list_map: map<key: int32, value: list<$data$: int32>>
 * >
 * where there is one row per requested piece of metadata information.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetSqlInfo
 */
export type CommandGetSqlInfo = Message<"arrow.flight.protocol.sql.CommandGetSqlInfo"> & {
  /**
   *
   * Values are modelled after ODBC's SQLGetInfo() function. This information is intended to provide
   * Flight SQL clients with basic, SQL syntax and SQL functions related information.
   * More information types can be added in future releases.
   * E.g. more SQL syntax support types, scalar functions support, type conversion support etc.
   *
   * Note that the set of metadata may expand.
   *
   * Initially, Flight SQL will support the following information types:
   * - Server Information - Range [0-500)
   * - Syntax Information - Range [500-1000)
   * Range [0-10,000) is reserved for defaults (see SqlInfo enum for default options).
   * Custom options should start at 10,000.
   *
   * If omitted, then all metadata will be retrieved.
   * Flight SQL Servers may choose to include additional metadata above and beyond the specified set, however they must
   * at least return the specified set. IDs ranging from 0 to 10,000 (exclusive) are reserved for future use.
   * If additional metadata is included, the metadata IDs should start from 10,000.
   *
   * @generated from field: repeated uint32 info = 1;
   */
  info: number[];
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetSqlInfo.
 * Use `create(CommandGetSqlInfoSchema)` to create a new message.
 */
export const CommandGetSqlInfoSchema: GenMessage<CommandGetSqlInfo> = /*@__PURE__*/
  messageDesc(file_FlightSql, 0);

/**
 *
 * Represents a request to retrieve information about data type supported on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned schema will be:
 * <
 *   type_name: utf8 not null (The name of the data type, for example: VARCHAR, INTEGER, etc),
 *   data_type: int32 not null (The SQL data type),
 *   column_size: int32 (The maximum size supported by that column.
 *                       In case of exact numeric types, this represents the maximum precision.
 *                       In case of string types, this represents the character length.
 *                       In case of datetime data types, this represents the length in characters of the string representation.
 *                       NULL is returned for data types where column size is not applicable.),
 *   literal_prefix: utf8 (Character or characters used to prefix a literal, NULL is returned for
 *                         data types where a literal prefix is not applicable.),
 *   literal_suffix: utf8 (Character or characters used to terminate a literal,
 *                         NULL is returned for data types where a literal suffix is not applicable.),
 *   create_params: list<utf8 not null>
 *                        (A list of keywords corresponding to which parameters can be used when creating
 *                         a column for that specific type.
 *                         NULL is returned if there are no parameters for the data type definition.),
 *   nullable: int32 not null (Shows if the data type accepts a NULL value. The possible values can be seen in the
 *                             Nullable enum.),
 *   case_sensitive: bool not null (Shows if a character data type is case-sensitive in collations and comparisons),
 *   searchable: int32 not null (Shows how the data type is used in a WHERE clause. The possible values can be seen in the
 *                               Searchable enum.),
 *   unsigned_attribute: bool (Shows if the data type is unsigned. NULL is returned if the attribute is
 *                             not applicable to the data type or the data type is not numeric.),
 *   fixed_prec_scale: bool not null (Shows if the data type has predefined fixed precision and scale.),
 *   auto_increment: bool (Shows if the data type is auto incremental. NULL is returned if the attribute
 *                         is not applicable to the data type or the data type is not numeric.),
 *   local_type_name: utf8 (Localized version of the data source-dependent name of the data type. NULL
 *                          is returned if a localized name is not supported by the data source),
 *   minimum_scale: int32 (The minimum scale of the data type on the data source.
 *                         If a data type has a fixed scale, the MINIMUM_SCALE and MAXIMUM_SCALE
 *                         columns both contain this value. NULL is returned if scale is not applicable.),
 *   maximum_scale: int32 (The maximum scale of the data type on the data source.
 *                         NULL is returned if scale is not applicable.),
 *   sql_data_type: int32 not null (The value of the SQL DATA TYPE which has the same values
 *                                  as data_type value. Except for interval and datetime, which
 *                                  uses generic values. More info about those types can be
 *                                  obtained through datetime_subcode. The possible values can be seen
 *                                  in the XdbcDataType enum.),
 *   datetime_subcode: int32 (Only used when the SQL DATA TYPE is interval or datetime. It contains
 *                            its sub types. For type different from interval and datetime, this value
 *                            is NULL. The possible values can be seen in the XdbcDatetimeSubcode enum.),
 *   num_prec_radix: int32 (If the data type is an approximate numeric type, this column contains
 *                          the value 2 to indicate that COLUMN_SIZE specifies a number of bits. For
 *                          exact numeric types, this column contains the value 10 to indicate that
 *                          column size specifies a number of decimal digits. Otherwise, this column is NULL.),
 *   interval_precision: int32 (If the data type is an interval data type, then this column contains the value
 *                              of the interval leading precision. Otherwise, this column is NULL. This fields
 *                              is only relevant to be used by ODBC).
 * >
 * The returned data should be ordered by data_type and then by type_name.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetXdbcTypeInfo
 */
export type CommandGetXdbcTypeInfo = Message<"arrow.flight.protocol.sql.CommandGetXdbcTypeInfo"> & {
  /**
   *
   * Specifies the data type to search for the info.
   *
   * @generated from field: optional int32 data_type = 1;
   */
  dataType?: number;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetXdbcTypeInfo.
 * Use `create(CommandGetXdbcTypeInfoSchema)` to create a new message.
 */
export const CommandGetXdbcTypeInfoSchema: GenMessage<CommandGetXdbcTypeInfo> = /*@__PURE__*/
  messageDesc(file_FlightSql, 1);

/**
 *
 * Represents a request to retrieve the list of catalogs on a Flight SQL enabled backend.
 * The definition of a catalog depends on vendor/implementation. It is usually the database itself
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8 not null
 * >
 * The returned data should be ordered by catalog_name.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetCatalogs
 */
export type CommandGetCatalogs = Message<"arrow.flight.protocol.sql.CommandGetCatalogs"> & {
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetCatalogs.
 * Use `create(CommandGetCatalogsSchema)` to create a new message.
 */
export const CommandGetCatalogsSchema: GenMessage<CommandGetCatalogs> = /*@__PURE__*/
  messageDesc(file_FlightSql, 2);

/**
 *
 * Represents a request to retrieve the list of database schemas on a Flight SQL enabled backend.
 * The definition of a database schema depends on vendor/implementation. It is usually a collection of tables.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8,
 *  db_schema_name: utf8 not null
 * >
 * The returned data should be ordered by catalog_name, then db_schema_name.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetDbSchemas
 */
export type CommandGetDbSchemas = Message<"arrow.flight.protocol.sql.CommandGetDbSchemas"> & {
  /**
   *
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string catalog = 1;
   */
  catalog?: string;

  /**
   *
   * Specifies a filter pattern for schemas to search for.
   * When no db_schema_filter_pattern is provided, the pattern will not be used to narrow the search.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   *
   * @generated from field: optional string db_schema_filter_pattern = 2;
   */
  dbSchemaFilterPattern?: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetDbSchemas.
 * Use `create(CommandGetDbSchemasSchema)` to create a new message.
 */
export const CommandGetDbSchemasSchema: GenMessage<CommandGetDbSchemas> = /*@__PURE__*/
  messageDesc(file_FlightSql, 3);

/**
 *
 * Represents a request to retrieve the list of tables, and optionally their schemas, on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8,
 *  db_schema_name: utf8,
 *  table_name: utf8 not null,
 *  table_type: utf8 not null,
 *  [optional] table_schema: bytes not null (schema of the table as described in Schema.fbs::Schema,
 *                                           it is serialized as an IPC message.)
 * >
 * Fields on table_schema may contain the following metadata:
 *  - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
 *  - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
 *  - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
 *  - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
 *  - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
 *  - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
 *  - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
 *  - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case-sensitive, "0" otherwise.
 *  - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
 *  - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
 *  - ARROW:FLIGHT:SQL:REMARKS           - A comment describing the column. This field has been added after all others, clients should be prepared to find it missing.
 * The returned data should be ordered by catalog_name, db_schema_name, table_name, then table_type, followed by table_schema if requested.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetTables
 */
export type CommandGetTables = Message<"arrow.flight.protocol.sql.CommandGetTables"> & {
  /**
   *
   * Specifies the Catalog to search for the tables.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string catalog = 1;
   */
  catalog?: string;

  /**
   *
   * Specifies a filter pattern for schemas to search for.
   * When no db_schema_filter_pattern is provided, all schemas matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   *
   * @generated from field: optional string db_schema_filter_pattern = 2;
   */
  dbSchemaFilterPattern?: string;

  /**
   *
   * Specifies a filter pattern for tables to search for.
   * When no table_name_filter_pattern is provided, all tables matching other filters are searched.
   * In the pattern string, two special characters can be used to denote matching rules:
   *    - "%" means to match any substring with 0 or more characters.
   *    - "_" means to match any one character.
   *
   * @generated from field: optional string table_name_filter_pattern = 3;
   */
  tableNameFilterPattern?: string;

  /**
   *
   * Specifies a filter of table types which must match.
   * The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
   * TABLE, VIEW, and SYSTEM TABLE are commonly supported.
   *
   * @generated from field: repeated string table_types = 4;
   */
  tableTypes: string[];

  /**
   * Specifies if the Arrow schema should be returned for found tables.
   *
   * @generated from field: bool include_schema = 5;
   */
  includeSchema: boolean;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetTables.
 * Use `create(CommandGetTablesSchema)` to create a new message.
 */
export const CommandGetTablesSchema: GenMessage<CommandGetTables> = /*@__PURE__*/
  messageDesc(file_FlightSql, 4);

/**
 *
 * Represents a request to retrieve the list of table types on a Flight SQL enabled backend.
 * The table types depend on vendor/implementation. It is usually used to separate tables from views or system tables.
 * TABLE, VIEW, and SYSTEM TABLE are commonly supported.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  table_type: utf8 not null
 * >
 * The returned data should be ordered by table_type.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetTableTypes
 */
export type CommandGetTableTypes = Message<"arrow.flight.protocol.sql.CommandGetTableTypes"> & {
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetTableTypes.
 * Use `create(CommandGetTableTypesSchema)` to create a new message.
 */
export const CommandGetTableTypesSchema: GenMessage<CommandGetTableTypes> = /*@__PURE__*/
  messageDesc(file_FlightSql, 5);

/**
 *
 * Represents a request to retrieve the primary keys of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  catalog_name: utf8,
 *  db_schema_name: utf8,
 *  table_name: utf8 not null,
 *  column_name: utf8 not null,
 *  key_name: utf8,
 *  key_sequence: int32 not null
 * >
 * The returned data should be ordered by catalog_name, db_schema_name, table_name, key_name, then key_sequence.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetPrimaryKeys
 */
export type CommandGetPrimaryKeys = Message<"arrow.flight.protocol.sql.CommandGetPrimaryKeys"> & {
  /**
   *
   * Specifies the catalog to search for the table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string catalog = 1;
   */
  catalog?: string;

  /**
   *
   * Specifies the schema to search for the table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   *
   * @generated from field: optional string db_schema = 2;
   */
  dbSchema?: string;

  /**
   * Specifies the table to get the primary keys for.
   *
   * @generated from field: string table = 3;
   */
  table: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetPrimaryKeys.
 * Use `create(CommandGetPrimaryKeysSchema)` to create a new message.
 */
export const CommandGetPrimaryKeysSchema: GenMessage<CommandGetPrimaryKeys> = /*@__PURE__*/
  messageDesc(file_FlightSql, 6);

/**
 *
 * Represents a request to retrieve a description of the foreign key columns that reference the given table's
 * primary key columns (the foreign keys exported by a table) of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_db_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_db_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int32 not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint8 not null,
 *  delete_rule: uint8 not null
 * >
 * The returned data should be ordered by fk_catalog_name, fk_db_schema_name, fk_table_name, fk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions declared on UpdateDeleteRules enum.
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetExportedKeys
 */
export type CommandGetExportedKeys = Message<"arrow.flight.protocol.sql.CommandGetExportedKeys"> & {
  /**
   *
   * Specifies the catalog to search for the foreign key table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string catalog = 1;
   */
  catalog?: string;

  /**
   *
   * Specifies the schema to search for the foreign key table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   *
   * @generated from field: optional string db_schema = 2;
   */
  dbSchema?: string;

  /**
   * Specifies the foreign key table to get the foreign keys for.
   *
   * @generated from field: string table = 3;
   */
  table: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetExportedKeys.
 * Use `create(CommandGetExportedKeysSchema)` to create a new message.
 */
export const CommandGetExportedKeysSchema: GenMessage<CommandGetExportedKeys> = /*@__PURE__*/
  messageDesc(file_FlightSql, 7);

/**
 *
 * Represents a request to retrieve the foreign keys of a table on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_db_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_db_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int32 not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint8 not null,
 *  delete_rule: uint8 not null
 * >
 * The returned data should be ordered by pk_catalog_name, pk_db_schema_name, pk_table_name, pk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions:
 *    - 0 = CASCADE
 *    - 1 = RESTRICT
 *    - 2 = SET NULL
 *    - 3 = NO ACTION
 *    - 4 = SET DEFAULT
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetImportedKeys
 */
export type CommandGetImportedKeys = Message<"arrow.flight.protocol.sql.CommandGetImportedKeys"> & {
  /**
   *
   * Specifies the catalog to search for the primary key table.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string catalog = 1;
   */
  catalog?: string;

  /**
   *
   * Specifies the schema to search for the primary key table.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   *
   * @generated from field: optional string db_schema = 2;
   */
  dbSchema?: string;

  /**
   * Specifies the primary key table to get the foreign keys for.
   *
   * @generated from field: string table = 3;
   */
  table: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetImportedKeys.
 * Use `create(CommandGetImportedKeysSchema)` to create a new message.
 */
export const CommandGetImportedKeysSchema: GenMessage<CommandGetImportedKeys> = /*@__PURE__*/
  messageDesc(file_FlightSql, 8);

/**
 *
 * Represents a request to retrieve a description of the foreign key columns in the given foreign key table that
 * reference the primary key or the columns representing a unique constraint of the parent table (could be the same
 * or a different table) on a Flight SQL enabled backend.
 * Used in the command member of FlightDescriptor for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *  - GetFlightInfo: execute the catalog metadata request.
 *
 * The returned Arrow schema will be:
 * <
 *  pk_catalog_name: utf8,
 *  pk_db_schema_name: utf8,
 *  pk_table_name: utf8 not null,
 *  pk_column_name: utf8 not null,
 *  fk_catalog_name: utf8,
 *  fk_db_schema_name: utf8,
 *  fk_table_name: utf8 not null,
 *  fk_column_name: utf8 not null,
 *  key_sequence: int32 not null,
 *  fk_key_name: utf8,
 *  pk_key_name: utf8,
 *  update_rule: uint8 not null,
 *  delete_rule: uint8 not null
 * >
 * The returned data should be ordered by pk_catalog_name, pk_db_schema_name, pk_table_name, pk_key_name, then key_sequence.
 * update_rule and delete_rule returns a byte that is equivalent to actions:
 *    - 0 = CASCADE
 *    - 1 = RESTRICT
 *    - 2 = SET NULL
 *    - 3 = NO ACTION
 *    - 4 = SET DEFAULT
 *
 * @generated from message arrow.flight.protocol.sql.CommandGetCrossReference
 */
export type CommandGetCrossReference = Message<"arrow.flight.protocol.sql.CommandGetCrossReference"> & {
  /**
   * *
   * The catalog name where the parent table is.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string pk_catalog = 1;
   */
  pkCatalog?: string;

  /**
   * *
   * The Schema name where the parent table is.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   *
   * @generated from field: optional string pk_db_schema = 2;
   */
  pkDbSchema?: string;

  /**
   * *
   * The parent table name. It cannot be null.
   *
   * @generated from field: string pk_table = 3;
   */
  pkTable: string;

  /**
   * *
   * The catalog name where the foreign table is.
   * An empty string retrieves those without a catalog.
   * If omitted the catalog name should not be used to narrow the search.
   *
   * @generated from field: optional string fk_catalog = 4;
   */
  fkCatalog?: string;

  /**
   * *
   * The schema name where the foreign table is.
   * An empty string retrieves those without a schema.
   * If omitted the schema name should not be used to narrow the search.
   *
   * @generated from field: optional string fk_db_schema = 5;
   */
  fkDbSchema?: string;

  /**
   * *
   * The foreign table name. It cannot be null.
   *
   * @generated from field: string fk_table = 6;
   */
  fkTable: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandGetCrossReference.
 * Use `create(CommandGetCrossReferenceSchema)` to create a new message.
 */
export const CommandGetCrossReferenceSchema: GenMessage<CommandGetCrossReference> = /*@__PURE__*/
  messageDesc(file_FlightSql, 9);

/**
 *
 * Request message for the "CreatePreparedStatement" action on a Flight SQL enabled backend.
 *
 * @generated from message arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest
 */
export type ActionCreatePreparedStatementRequest = Message<"arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest"> & {
  /**
   * The valid SQL string to create a prepared statement for.
   *
   * @generated from field: string query = 1;
   */
  query: string;

  /**
   * Create/execute the prepared statement as part of this transaction (if
   * unset, executions of the prepared statement will be auto-committed).
   *
   * @generated from field: optional bytes transaction_id = 2;
   */
  transactionId?: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionCreatePreparedStatementRequest.
 * Use `create(ActionCreatePreparedStatementRequestSchema)` to create a new message.
 */
export const ActionCreatePreparedStatementRequestSchema: GenMessage<ActionCreatePreparedStatementRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 10);

/**
 *
 * An embedded message describing a Substrait plan to execute.
 *
 * @generated from message arrow.flight.protocol.sql.SubstraitPlan
 */
export type SubstraitPlan = Message<"arrow.flight.protocol.sql.SubstraitPlan"> & {
  /**
   * The serialized substrait.Plan to create a prepared statement for.
   * XXX(ARROW-16902): this is bytes instead of an embedded message
   * because Protobuf does not really support one DLL using Protobuf
   * definitions from another DLL.
   *
   * @generated from field: bytes plan = 1;
   */
  plan: Uint8Array;

  /**
   * The Substrait release, e.g. "0.12.0". This information is not
   * tracked in the plan itself, so this is the only way for consumers
   * to potentially know if they can handle the plan.
   *
   * @generated from field: string version = 2;
   */
  version: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.SubstraitPlan.
 * Use `create(SubstraitPlanSchema)` to create a new message.
 */
export const SubstraitPlanSchema: GenMessage<SubstraitPlan> = /*@__PURE__*/
  messageDesc(file_FlightSql, 11);

/**
 *
 * Request message for the "CreatePreparedSubstraitPlan" action on a Flight SQL enabled backend.
 *
 * @generated from message arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest
 */
export type ActionCreatePreparedSubstraitPlanRequest = Message<"arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest"> & {
  /**
   * The serialized substrait.Plan to create a prepared statement for.
   *
   * @generated from field: arrow.flight.protocol.sql.SubstraitPlan plan = 1;
   */
  plan?: SubstraitPlan;

  /**
   * Create/execute the prepared statement as part of this transaction (if
   * unset, executions of the prepared statement will be auto-committed).
   *
   * @generated from field: optional bytes transaction_id = 2;
   */
  transactionId?: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionCreatePreparedSubstraitPlanRequest.
 * Use `create(ActionCreatePreparedSubstraitPlanRequestSchema)` to create a new message.
 */
export const ActionCreatePreparedSubstraitPlanRequestSchema: GenMessage<ActionCreatePreparedSubstraitPlanRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 12);

/**
 *
 * Wrap the result of a "CreatePreparedStatement" or "CreatePreparedSubstraitPlan" action.
 *
 * The resultant PreparedStatement can be closed either:
 * - Manually, through the "ClosePreparedStatement" action;
 * - Automatically, by a server timeout.
 *
 * The result should be wrapped in a google.protobuf.Any message.
 *
 * @generated from message arrow.flight.protocol.sql.ActionCreatePreparedStatementResult
 */
export type ActionCreatePreparedStatementResult = Message<"arrow.flight.protocol.sql.ActionCreatePreparedStatementResult"> & {
  /**
   * Opaque handle for the prepared statement on the server.
   *
   * @generated from field: bytes prepared_statement_handle = 1;
   */
  preparedStatementHandle: Uint8Array;

  /**
   * If a result set generating query was provided, dataset_schema contains the
   * schema of the result set.  It should be an IPC-encapsulated Schema, as described in Schema.fbs.
   * For some queries, the schema of the results may depend on the schema of the parameters.  The server
   * should provide its best guess as to the schema at this point.  Clients must not assume that this
   * schema, if provided, will be accurate.
   *
   * @generated from field: bytes dataset_schema = 2;
   */
  datasetSchema: Uint8Array;

  /**
   * If the query provided contained parameters, parameter_schema contains the
   * schema of the expected parameters.  It should be an IPC-encapsulated Schema, as described in Schema.fbs.
   *
   * @generated from field: bytes parameter_schema = 3;
   */
  parameterSchema: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionCreatePreparedStatementResult.
 * Use `create(ActionCreatePreparedStatementResultSchema)` to create a new message.
 */
export const ActionCreatePreparedStatementResultSchema: GenMessage<ActionCreatePreparedStatementResult> = /*@__PURE__*/
  messageDesc(file_FlightSql, 13);

/**
 *
 * Request message for the "ClosePreparedStatement" action on a Flight SQL enabled backend.
 * Closes server resources associated with the prepared statement handle.
 *
 * @generated from message arrow.flight.protocol.sql.ActionClosePreparedStatementRequest
 */
export type ActionClosePreparedStatementRequest = Message<"arrow.flight.protocol.sql.ActionClosePreparedStatementRequest"> & {
  /**
   * Opaque handle for the prepared statement on the server.
   *
   * @generated from field: bytes prepared_statement_handle = 1;
   */
  preparedStatementHandle: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionClosePreparedStatementRequest.
 * Use `create(ActionClosePreparedStatementRequestSchema)` to create a new message.
 */
export const ActionClosePreparedStatementRequestSchema: GenMessage<ActionClosePreparedStatementRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 14);

/**
 *
 * Request message for the "BeginTransaction" action.
 * Begins a transaction.
 *
 * @generated from message arrow.flight.protocol.sql.ActionBeginTransactionRequest
 */
export type ActionBeginTransactionRequest = Message<"arrow.flight.protocol.sql.ActionBeginTransactionRequest"> & {
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionBeginTransactionRequest.
 * Use `create(ActionBeginTransactionRequestSchema)` to create a new message.
 */
export const ActionBeginTransactionRequestSchema: GenMessage<ActionBeginTransactionRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 15);

/**
 *
 * Request message for the "BeginSavepoint" action.
 * Creates a savepoint within a transaction.
 *
 * Only supported if FLIGHT_SQL_TRANSACTION is
 * FLIGHT_SQL_TRANSACTION_SUPPORT_SAVEPOINT.
 *
 * @generated from message arrow.flight.protocol.sql.ActionBeginSavepointRequest
 */
export type ActionBeginSavepointRequest = Message<"arrow.flight.protocol.sql.ActionBeginSavepointRequest"> & {
  /**
   * The transaction to which a savepoint belongs.
   *
   * @generated from field: bytes transaction_id = 1;
   */
  transactionId: Uint8Array;

  /**
   * Name for the savepoint.
   *
   * @generated from field: string name = 2;
   */
  name: string;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionBeginSavepointRequest.
 * Use `create(ActionBeginSavepointRequestSchema)` to create a new message.
 */
export const ActionBeginSavepointRequestSchema: GenMessage<ActionBeginSavepointRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 16);

/**
 *
 * The result of a "BeginTransaction" action.
 *
 * The transaction can be manipulated with the "EndTransaction" action, or
 * automatically via server timeout. If the transaction times out, then it is
 * automatically rolled back.
 *
 * The result should be wrapped in a google.protobuf.Any message.
 *
 * @generated from message arrow.flight.protocol.sql.ActionBeginTransactionResult
 */
export type ActionBeginTransactionResult = Message<"arrow.flight.protocol.sql.ActionBeginTransactionResult"> & {
  /**
   * Opaque handle for the transaction on the server.
   *
   * @generated from field: bytes transaction_id = 1;
   */
  transactionId: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionBeginTransactionResult.
 * Use `create(ActionBeginTransactionResultSchema)` to create a new message.
 */
export const ActionBeginTransactionResultSchema: GenMessage<ActionBeginTransactionResult> = /*@__PURE__*/
  messageDesc(file_FlightSql, 17);

/**
 *
 * The result of a "BeginSavepoint" action.
 *
 * The transaction can be manipulated with the "EndSavepoint" action.
 * If the associated transaction is committed, rolled back, or times
 * out, then the savepoint is also invalidated.
 *
 * The result should be wrapped in a google.protobuf.Any message.
 *
 * @generated from message arrow.flight.protocol.sql.ActionBeginSavepointResult
 */
export type ActionBeginSavepointResult = Message<"arrow.flight.protocol.sql.ActionBeginSavepointResult"> & {
  /**
   * Opaque handle for the savepoint on the server.
   *
   * @generated from field: bytes savepoint_id = 1;
   */
  savepointId: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionBeginSavepointResult.
 * Use `create(ActionBeginSavepointResultSchema)` to create a new message.
 */
export const ActionBeginSavepointResultSchema: GenMessage<ActionBeginSavepointResult> = /*@__PURE__*/
  messageDesc(file_FlightSql, 18);

/**
 *
 * Request message for the "EndTransaction" action.
 *
 * Commit (COMMIT) or rollback (ROLLBACK) the transaction.
 *
 * If the action completes successfully, the transaction handle is
 * invalidated, as are all associated savepoints.
 *
 * @generated from message arrow.flight.protocol.sql.ActionEndTransactionRequest
 */
export type ActionEndTransactionRequest = Message<"arrow.flight.protocol.sql.ActionEndTransactionRequest"> & {
  /**
   * Opaque handle for the transaction on the server.
   *
   * @generated from field: bytes transaction_id = 1;
   */
  transactionId: Uint8Array;

  /**
   * Whether to commit/rollback the given transaction.
   *
   * @generated from field: arrow.flight.protocol.sql.ActionEndTransactionRequest.EndTransaction action = 2;
   */
  action: ActionEndTransactionRequest_EndTransaction;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionEndTransactionRequest.
 * Use `create(ActionEndTransactionRequestSchema)` to create a new message.
 */
export const ActionEndTransactionRequestSchema: GenMessage<ActionEndTransactionRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 19);

/**
 * @generated from enum arrow.flight.protocol.sql.ActionEndTransactionRequest.EndTransaction
 */
export enum ActionEndTransactionRequest_EndTransaction {
  /**
   * @generated from enum value: END_TRANSACTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Commit the transaction.
   *
   * @generated from enum value: END_TRANSACTION_COMMIT = 1;
   */
  COMMIT = 1,

  /**
   * Roll back the transaction.
   *
   * @generated from enum value: END_TRANSACTION_ROLLBACK = 2;
   */
  ROLLBACK = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.ActionEndTransactionRequest.EndTransaction.
 */
export const ActionEndTransactionRequest_EndTransactionSchema: GenEnum<ActionEndTransactionRequest_EndTransaction> = /*@__PURE__*/
  enumDesc(file_FlightSql, 19, 0);

/**
 *
 * Request message for the "EndSavepoint" action.
 *
 * Release (RELEASE) the savepoint or rollback (ROLLBACK) to the
 * savepoint.
 *
 * Releasing a savepoint invalidates that savepoint.  Rolling back to
 * a savepoint does not invalidate the savepoint, but invalidates all
 * savepoints created after the current savepoint.
 *
 * @generated from message arrow.flight.protocol.sql.ActionEndSavepointRequest
 */
export type ActionEndSavepointRequest = Message<"arrow.flight.protocol.sql.ActionEndSavepointRequest"> & {
  /**
   * Opaque handle for the savepoint on the server.
   *
   * @generated from field: bytes savepoint_id = 1;
   */
  savepointId: Uint8Array;

  /**
   * Whether to rollback/release the given savepoint.
   *
   * @generated from field: arrow.flight.protocol.sql.ActionEndSavepointRequest.EndSavepoint action = 2;
   */
  action: ActionEndSavepointRequest_EndSavepoint;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionEndSavepointRequest.
 * Use `create(ActionEndSavepointRequestSchema)` to create a new message.
 */
export const ActionEndSavepointRequestSchema: GenMessage<ActionEndSavepointRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 20);

/**
 * @generated from enum arrow.flight.protocol.sql.ActionEndSavepointRequest.EndSavepoint
 */
export enum ActionEndSavepointRequest_EndSavepoint {
  /**
   * @generated from enum value: END_SAVEPOINT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Release the savepoint.
   *
   * @generated from enum value: END_SAVEPOINT_RELEASE = 1;
   */
  RELEASE = 1,

  /**
   * Roll back to a savepoint.
   *
   * @generated from enum value: END_SAVEPOINT_ROLLBACK = 2;
   */
  ROLLBACK = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.ActionEndSavepointRequest.EndSavepoint.
 */
export const ActionEndSavepointRequest_EndSavepointSchema: GenEnum<ActionEndSavepointRequest_EndSavepoint> = /*@__PURE__*/
  enumDesc(file_FlightSql, 20, 0);

/**
 *
 * Represents a SQL query. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *    Fields on this schema may contain the following metadata:
 *    - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
 *    - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
 *    - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
 *    - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
 *    - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
 *    - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
 *    - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case-sensitive, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:REMARKS           - A comment describing the column. This field has been added after all others, clients should be prepared to find it missing.
 *  - GetFlightInfo: execute the query.
 *
 * @generated from message arrow.flight.protocol.sql.CommandStatementQuery
 */
export type CommandStatementQuery = Message<"arrow.flight.protocol.sql.CommandStatementQuery"> & {
  /**
   * The SQL syntax.
   *
   * @generated from field: string query = 1;
   */
  query: string;

  /**
   * Include the query as part of this transaction (if unset, the query is auto-committed).
   *
   * @generated from field: optional bytes transaction_id = 2;
   */
  transactionId?: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandStatementQuery.
 * Use `create(CommandStatementQuerySchema)` to create a new message.
 */
export const CommandStatementQuerySchema: GenMessage<CommandStatementQuery> = /*@__PURE__*/
  messageDesc(file_FlightSql, 21);

/**
 *
 * Represents a Substrait plan. Used in the command member of FlightDescriptor
 * for the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *    Fields on this schema may contain the following metadata:
 *    - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
 *    - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
 *    - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
 *    - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
 *    - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
 *    - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
 *    - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case-sensitive, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:REMARKS           - A comment describing the column. This field has been added after all others, clients should be prepared to find it missing.
 *  - GetFlightInfo: execute the query.
 *  - DoPut: execute the query.
 *
 * @generated from message arrow.flight.protocol.sql.CommandStatementSubstraitPlan
 */
export type CommandStatementSubstraitPlan = Message<"arrow.flight.protocol.sql.CommandStatementSubstraitPlan"> & {
  /**
   * A serialized substrait.Plan
   *
   * @generated from field: arrow.flight.protocol.sql.SubstraitPlan plan = 1;
   */
  plan?: SubstraitPlan;

  /**
   * Include the query as part of this transaction (if unset, the query is auto-committed).
   *
   * @generated from field: optional bytes transaction_id = 2;
   */
  transactionId?: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandStatementSubstraitPlan.
 * Use `create(CommandStatementSubstraitPlanSchema)` to create a new message.
 */
export const CommandStatementSubstraitPlanSchema: GenMessage<CommandStatementSubstraitPlan> = /*@__PURE__*/
  messageDesc(file_FlightSql, 22);

/**
 * *
 * Represents a ticket resulting from GetFlightInfo with a CommandStatementQuery.
 * This should be used only once and treated as an opaque value, that is, clients should not attempt to parse this.
 *
 * @generated from message arrow.flight.protocol.sql.TicketStatementQuery
 */
export type TicketStatementQuery = Message<"arrow.flight.protocol.sql.TicketStatementQuery"> & {
  /**
   * Unique identifier for the instance of the statement to execute.
   *
   * @generated from field: bytes statement_handle = 1;
   */
  statementHandle: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.TicketStatementQuery.
 * Use `create(TicketStatementQuerySchema)` to create a new message.
 */
export const TicketStatementQuerySchema: GenMessage<TicketStatementQuery> = /*@__PURE__*/
  messageDesc(file_FlightSql, 23);

/**
 *
 * Represents an instance of executing a prepared statement. Used in the command member of FlightDescriptor for
 * the following RPC calls:
 *  - GetSchema: return the Arrow schema of the query.
 *    Fields on this schema may contain the following metadata:
 *    - ARROW:FLIGHT:SQL:CATALOG_NAME      - Table's catalog name
 *    - ARROW:FLIGHT:SQL:DB_SCHEMA_NAME    - Database schema name
 *    - ARROW:FLIGHT:SQL:TABLE_NAME        - Table name
 *    - ARROW:FLIGHT:SQL:TYPE_NAME         - The data source-specific name for the data type of the column.
 *    - ARROW:FLIGHT:SQL:PRECISION         - Column precision/size
 *    - ARROW:FLIGHT:SQL:SCALE             - Column scale/decimal digits if applicable
 *    - ARROW:FLIGHT:SQL:IS_AUTO_INCREMENT - "1" indicates if the column is auto incremented, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_CASE_SENSITIVE - "1" indicates if the column is case-sensitive, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_READ_ONLY      - "1" indicates if the column is read only, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:IS_SEARCHABLE     - "1" indicates if the column is searchable via WHERE clause, "0" otherwise.
 *    - ARROW:FLIGHT:SQL:REMARKS           - A comment describing the column. This field has been added after all others, clients should be prepared to find it missing.
 *
 *    If the schema is retrieved after parameter values have been bound with DoPut, then the server should account
 *    for the parameters when determining the schema.
 *  - DoPut: bind parameter values. All of the bound parameter sets will be executed as a single atomic execution.
 *  - GetFlightInfo: execute the prepared statement instance.
 *
 * @generated from message arrow.flight.protocol.sql.CommandPreparedStatementQuery
 */
export type CommandPreparedStatementQuery = Message<"arrow.flight.protocol.sql.CommandPreparedStatementQuery"> & {
  /**
   * Opaque handle for the prepared statement on the server.
   *
   * @generated from field: bytes prepared_statement_handle = 1;
   */
  preparedStatementHandle: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandPreparedStatementQuery.
 * Use `create(CommandPreparedStatementQuerySchema)` to create a new message.
 */
export const CommandPreparedStatementQuerySchema: GenMessage<CommandPreparedStatementQuery> = /*@__PURE__*/
  messageDesc(file_FlightSql, 24);

/**
 *
 * Represents a SQL update query. Used in the command member of FlightDescriptor
 * for the RPC call DoPut to cause the server to execute the included SQL update.
 *
 * @generated from message arrow.flight.protocol.sql.CommandStatementUpdate
 */
export type CommandStatementUpdate = Message<"arrow.flight.protocol.sql.CommandStatementUpdate"> & {
  /**
   * The SQL syntax.
   *
   * @generated from field: string query = 1;
   */
  query: string;

  /**
   * Include the query as part of this transaction (if unset, the query is auto-committed).
   *
   * @generated from field: optional bytes transaction_id = 2;
   */
  transactionId?: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandStatementUpdate.
 * Use `create(CommandStatementUpdateSchema)` to create a new message.
 */
export const CommandStatementUpdateSchema: GenMessage<CommandStatementUpdate> = /*@__PURE__*/
  messageDesc(file_FlightSql, 25);

/**
 *
 * Represents a SQL update query. Used in the command member of FlightDescriptor
 * for the RPC call DoPut to cause the server to execute the included
 * prepared statement handle as an update.
 *
 * @generated from message arrow.flight.protocol.sql.CommandPreparedStatementUpdate
 */
export type CommandPreparedStatementUpdate = Message<"arrow.flight.protocol.sql.CommandPreparedStatementUpdate"> & {
  /**
   * Opaque handle for the prepared statement on the server.
   *
   * @generated from field: bytes prepared_statement_handle = 1;
   */
  preparedStatementHandle: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandPreparedStatementUpdate.
 * Use `create(CommandPreparedStatementUpdateSchema)` to create a new message.
 */
export const CommandPreparedStatementUpdateSchema: GenMessage<CommandPreparedStatementUpdate> = /*@__PURE__*/
  messageDesc(file_FlightSql, 26);

/**
 *
 * Represents a bulk ingestion request. Used in the command member of FlightDescriptor
 * for the the RPC call DoPut to cause the server load the contents of the stream's
 * FlightData into the target destination.
 *
 * @generated from message arrow.flight.protocol.sql.CommandStatementIngest
 */
export type CommandStatementIngest = Message<"arrow.flight.protocol.sql.CommandStatementIngest"> & {
  /**
   * The behavior for handling the table definition.
   *
   * @generated from field: arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions table_definition_options = 1;
   */
  tableDefinitionOptions?: CommandStatementIngest_TableDefinitionOptions;

  /**
   * The table to load data into.
   *
   * @generated from field: string table = 2;
   */
  table: string;

  /**
   * The db_schema of the destination table to load data into. If unset, a backend-specific default may be used.
   *
   * @generated from field: optional string schema = 3;
   */
  schema?: string;

  /**
   * The catalog of the destination table to load data into. If unset, a backend-specific default may be used.
   *
   * @generated from field: optional string catalog = 4;
   */
  catalog?: string;

  /**
   *
   * Store ingested data in a temporary table.
   * The effect of setting temporary is to place the table in a backend-defined namespace, and to drop the table at the end of the session.
   * The namespacing may make use of a backend-specific schema and/or catalog.
   * The server should return an error if an explicit choice of schema or catalog is incompatible with the server's namespacing decision.
   *
   * @generated from field: bool temporary = 5;
   */
  temporary: boolean;

  /**
   * Perform the ingestion as part of this transaction. If specified, results should not be committed in the event of an error/cancellation.
   *
   * @generated from field: optional bytes transaction_id = 6;
   */
  transactionId?: Uint8Array;

  /**
   * Backend-specific options.
   *
   * @generated from field: map<string, string> options = 1000;
   */
  options: { [key: string]: string };
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandStatementIngest.
 * Use `create(CommandStatementIngestSchema)` to create a new message.
 */
export const CommandStatementIngestSchema: GenMessage<CommandStatementIngest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 27);

/**
 * Options for table definition behavior
 *
 * @generated from message arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions
 */
export type CommandStatementIngest_TableDefinitionOptions = Message<"arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions"> & {
  /**
   * @generated from field: arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableNotExistOption if_not_exist = 1;
   */
  ifNotExist: CommandStatementIngest_TableDefinitionOptions_TableNotExistOption;

  /**
   * @generated from field: arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableExistsOption if_exists = 2;
   */
  ifExists: CommandStatementIngest_TableDefinitionOptions_TableExistsOption;
};

/**
 * Describes the message arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.
 * Use `create(CommandStatementIngest_TableDefinitionOptionsSchema)` to create a new message.
 */
export const CommandStatementIngest_TableDefinitionOptionsSchema: GenMessage<CommandStatementIngest_TableDefinitionOptions> = /*@__PURE__*/
  messageDesc(file_FlightSql, 27, 0);

/**
 * The action to take if the target table does not exist
 *
 * @generated from enum arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableNotExistOption
 */
export enum CommandStatementIngest_TableDefinitionOptions_TableNotExistOption {
  /**
   * Do not use. Servers should error if this is specified by a client.
   *
   * @generated from enum value: TABLE_NOT_EXIST_OPTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Create the table if it does not exist
   *
   * @generated from enum value: TABLE_NOT_EXIST_OPTION_CREATE = 1;
   */
  CREATE = 1,

  /**
   * Fail if the table does not exist
   *
   * @generated from enum value: TABLE_NOT_EXIST_OPTION_FAIL = 2;
   */
  FAIL = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableNotExistOption.
 */
export const CommandStatementIngest_TableDefinitionOptions_TableNotExistOptionSchema: GenEnum<CommandStatementIngest_TableDefinitionOptions_TableNotExistOption> = /*@__PURE__*/
  enumDesc(file_FlightSql, 27, 0, 0);

/**
 * The action to take if the target table already exists
 *
 * @generated from enum arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableExistsOption
 */
export enum CommandStatementIngest_TableDefinitionOptions_TableExistsOption {
  /**
   * Do not use. Servers should error if this is specified by a client.
   *
   * @generated from enum value: TABLE_EXISTS_OPTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Fail if the table already exists
   *
   * @generated from enum value: TABLE_EXISTS_OPTION_FAIL = 1;
   */
  FAIL = 1,

  /**
   * Append to the table if it already exists
   *
   * @generated from enum value: TABLE_EXISTS_OPTION_APPEND = 2;
   */
  APPEND = 2,

  /**
   * Drop and recreate the table if it already exists
   *
   * @generated from enum value: TABLE_EXISTS_OPTION_REPLACE = 3;
   */
  REPLACE = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.CommandStatementIngest.TableDefinitionOptions.TableExistsOption.
 */
export const CommandStatementIngest_TableDefinitionOptions_TableExistsOptionSchema: GenEnum<CommandStatementIngest_TableDefinitionOptions_TableExistsOption> = /*@__PURE__*/
  enumDesc(file_FlightSql, 27, 0, 1);

/**
 *
 * Returned from the RPC call DoPut when a CommandStatementUpdate,
 * CommandPreparedStatementUpdate, or CommandStatementIngest was
 * in the request, containing results from the update.
 *
 * @generated from message arrow.flight.protocol.sql.DoPutUpdateResult
 */
export type DoPutUpdateResult = Message<"arrow.flight.protocol.sql.DoPutUpdateResult"> & {
  /**
   * The number of records updated. A return value of -1 represents
   * an unknown updated record count.
   *
   * @generated from field: int64 record_count = 1;
   */
  recordCount: bigint;
};

/**
 * Describes the message arrow.flight.protocol.sql.DoPutUpdateResult.
 * Use `create(DoPutUpdateResultSchema)` to create a new message.
 */
export const DoPutUpdateResultSchema: GenMessage<DoPutUpdateResult> = /*@__PURE__*/
  messageDesc(file_FlightSql, 28);

/**
 * An *optional* response returned when `DoPut` is called with `CommandPreparedStatementQuery`.
 *
 * *Note on legacy behavior*: previous versions of the protocol did not return any result for
 * this command, and that behavior should still be supported by clients. In that case, the client
 * can continue as though the fields in this message were not provided or set to sensible default values.
 *
 * @generated from message arrow.flight.protocol.sql.DoPutPreparedStatementResult
 */
export type DoPutPreparedStatementResult = Message<"arrow.flight.protocol.sql.DoPutPreparedStatementResult"> & {
  /**
   * Represents a (potentially updated) opaque handle for the prepared statement on the server.
   * Because the handle could potentially be updated, any previous handles for this prepared
   * statement should be considered invalid, and all subsequent requests for this prepared
   * statement must use this new handle.
   * The updated handle allows implementing query parameters with stateless services.
   *
   * When an updated handle is not provided by the server, clients should continue
   * using the previous handle provided by `ActionCreatePreparedStatementResonse`.
   *
   * @generated from field: optional bytes prepared_statement_handle = 1;
   */
  preparedStatementHandle?: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.DoPutPreparedStatementResult.
 * Use `create(DoPutPreparedStatementResultSchema)` to create a new message.
 */
export const DoPutPreparedStatementResultSchema: GenMessage<DoPutPreparedStatementResult> = /*@__PURE__*/
  messageDesc(file_FlightSql, 29);

/**
 *
 * Request message for the "CancelQuery" action.
 *
 * Explicitly cancel a running query.
 *
 * This lets a single client explicitly cancel work, no matter how many clients
 * are involved/whether the query is distributed or not, given server support.
 * The transaction/statement is not rolled back; it is the application's job to
 * commit or rollback as appropriate. This only indicates the client no longer
 * wishes to read the remainder of the query results or continue submitting
 * data.
 *
 * This command is idempotent.
 *
 * This command is deprecated since 13.0.0. Use the "CancelFlightInfo"
 * action with DoAction instead.
 *
 * @generated from message arrow.flight.protocol.sql.ActionCancelQueryRequest
 * @deprecated
 */
export type ActionCancelQueryRequest = Message<"arrow.flight.protocol.sql.ActionCancelQueryRequest"> & {
  /**
   * The result of the GetFlightInfo RPC that initiated the query.
   * XXX(ARROW-16902): this must be a serialized FlightInfo, but is
   * rendered as bytes because Protobuf does not really support one
   * DLL using Protobuf definitions from another DLL.
   *
   * @generated from field: bytes info = 1;
   */
  info: Uint8Array;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionCancelQueryRequest.
 * Use `create(ActionCancelQueryRequestSchema)` to create a new message.
 * @deprecated
 */
export const ActionCancelQueryRequestSchema: GenMessage<ActionCancelQueryRequest> = /*@__PURE__*/
  messageDesc(file_FlightSql, 30);

/**
 *
 * The result of cancelling a query.
 *
 * The result should be wrapped in a google.protobuf.Any message.
 *
 * This command is deprecated since 13.0.0. Use the "CancelFlightInfo"
 * action with DoAction instead.
 *
 * @generated from message arrow.flight.protocol.sql.ActionCancelQueryResult
 * @deprecated
 */
export type ActionCancelQueryResult = Message<"arrow.flight.protocol.sql.ActionCancelQueryResult"> & {
  /**
   * @generated from field: arrow.flight.protocol.sql.ActionCancelQueryResult.CancelResult result = 1;
   */
  result: ActionCancelQueryResult_CancelResult;
};

/**
 * Describes the message arrow.flight.protocol.sql.ActionCancelQueryResult.
 * Use `create(ActionCancelQueryResultSchema)` to create a new message.
 * @deprecated
 */
export const ActionCancelQueryResultSchema: GenMessage<ActionCancelQueryResult> = /*@__PURE__*/
  messageDesc(file_FlightSql, 31);

/**
 * @generated from enum arrow.flight.protocol.sql.ActionCancelQueryResult.CancelResult
 * @deprecated
 */
export enum ActionCancelQueryResult_CancelResult {
  /**
   * The cancellation status is unknown. Servers should avoid using
   * this value (send a NOT_FOUND error if the requested query is
   * not known). Clients can retry the request.
   *
   * @generated from enum value: CANCEL_RESULT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The cancellation request is complete. Subsequent requests with
   * the same payload may return CANCELLED or a NOT_FOUND error.
   *
   * @generated from enum value: CANCEL_RESULT_CANCELLED = 1;
   */
  CANCELLED = 1,

  /**
   * The cancellation request is in progress. The client may retry
   * the cancellation request.
   *
   * @generated from enum value: CANCEL_RESULT_CANCELLING = 2;
   */
  CANCELLING = 2,

  /**
   * The query is not cancellable. The client should not retry the
   * cancellation request.
   *
   * @generated from enum value: CANCEL_RESULT_NOT_CANCELLABLE = 3;
   */
  NOT_CANCELLABLE = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.ActionCancelQueryResult.CancelResult.
 * @deprecated
 */
export const ActionCancelQueryResult_CancelResultSchema: GenEnum<ActionCancelQueryResult_CancelResult> = /*@__PURE__*/
  enumDesc(file_FlightSql, 31, 0);

/**
 * Options for CommandGetSqlInfo.
 *
 * @generated from enum arrow.flight.protocol.sql.SqlInfo
 */
export enum SqlInfo {
  /**
   * Retrieves a UTF-8 string with the name of the Flight SQL Server.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_NAME = 0;
   */
  FLIGHT_SQL_SERVER_NAME = 0,

  /**
   * Retrieves a UTF-8 string with the native version of the Flight SQL Server.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_VERSION = 1;
   */
  FLIGHT_SQL_SERVER_VERSION = 1,

  /**
   * Retrieves a UTF-8 string with the Arrow format version of the Flight SQL Server.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_ARROW_VERSION = 2;
   */
  FLIGHT_SQL_SERVER_ARROW_VERSION = 2,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server is read only.
   *
   * Returns:
   * - false: if read-write
   * - true: if read only
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_READ_ONLY = 3;
   */
  FLIGHT_SQL_SERVER_READ_ONLY = 3,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server supports executing
   * SQL queries.
   *
   * Note that the absence of this info (as opposed to a false value) does not necessarily
   * mean that SQL is not supported, as this property was not originally defined.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_SQL = 4;
   */
  FLIGHT_SQL_SERVER_SQL = 4,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server supports executing
   * Substrait plans.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_SUBSTRAIT = 5;
   */
  FLIGHT_SQL_SERVER_SUBSTRAIT = 5,

  /**
   *
   * Retrieves a string value indicating the minimum supported Substrait version, or null
   * if Substrait is not supported.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION = 6;
   */
  FLIGHT_SQL_SERVER_SUBSTRAIT_MIN_VERSION = 6,

  /**
   *
   * Retrieves a string value indicating the maximum supported Substrait version, or null
   * if Substrait is not supported.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION = 7;
   */
  FLIGHT_SQL_SERVER_SUBSTRAIT_MAX_VERSION = 7,

  /**
   *
   * Retrieves an int32 indicating whether the Flight SQL Server supports the
   * BeginTransaction/EndTransaction/BeginSavepoint/EndSavepoint actions.
   *
   * Even if this is not supported, the database may still support explicit "BEGIN
   * TRANSACTION"/"COMMIT" SQL statements (see SQL_TRANSACTIONS_SUPPORTED); this property
   * is only about whether the server implements the Flight SQL API endpoints.
   *
   * The possible values are listed in `SqlSupportedTransaction`.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_TRANSACTION = 8;
   */
  FLIGHT_SQL_SERVER_TRANSACTION = 8,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server supports explicit
   * query cancellation (the CancelQuery action).
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_CANCEL = 9;
   */
  FLIGHT_SQL_SERVER_CANCEL = 9,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server supports executing
   * bulk ingestion.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_BULK_INGESTION = 10;
   */
  FLIGHT_SQL_SERVER_BULK_INGESTION = 10,

  /**
   *
   * Retrieves a boolean value indicating whether transactions are supported for bulk ingestion. If not, invoking
   * the method commit in the context of a bulk ingestion is a noop, and the isolation level is
   * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
   *
   * Returns:
   * - false: if bulk ingestion transactions are unsupported;
   * - true: if bulk ingestion transactions are supported.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED = 11;
   */
  FLIGHT_SQL_SERVER_INGEST_TRANSACTIONS_SUPPORTED = 11,

  /**
   *
   * Retrieves an int32 indicating the timeout (in milliseconds) for prepared statement handles.
   *
   * If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT = 100;
   */
  FLIGHT_SQL_SERVER_STATEMENT_TIMEOUT = 100,

  /**
   *
   * Retrieves an int32 indicating the timeout (in milliseconds) for transactions, since transactions are not tied to a connection.
   *
   * If 0, there is no timeout.  Servers should reset the timeout when the handle is used in a command.
   *
   * @generated from enum value: FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT = 101;
   */
  FLIGHT_SQL_SERVER_TRANSACTION_TIMEOUT = 101,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of catalogs.
   *
   * Returns:
   * - false: if it doesn't support CREATE and DROP of catalogs.
   * - true: if it supports CREATE and DROP of catalogs.
   *
   * @generated from enum value: SQL_DDL_CATALOG = 500;
   */
  SQL_DDL_CATALOG = 500,

  /**
   *
   * Retrieves a boolean value indicating whether the Flight SQL Server supports CREATE and DROP of schemas.
   *
   * Returns:
   * - false: if it doesn't support CREATE and DROP of schemas.
   * - true: if it supports CREATE and DROP of schemas.
   *
   * @generated from enum value: SQL_DDL_SCHEMA = 501;
   */
  SQL_DDL_SCHEMA = 501,

  /**
   *
   * Indicates whether the Flight SQL Server supports CREATE and DROP of tables.
   *
   * Returns:
   * - false: if it doesn't support CREATE and DROP of tables.
   * - true: if it supports CREATE and DROP of tables.
   *
   * @generated from enum value: SQL_DDL_TABLE = 502;
   */
  SQL_DDL_TABLE = 502,

  /**
   *
   * Retrieves a int32 ordinal representing the case sensitivity of catalog, table, schema and table names.
   *
   * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
   *
   * @generated from enum value: SQL_IDENTIFIER_CASE = 503;
   */
  SQL_IDENTIFIER_CASE = 503,

  /**
   * Retrieves a UTF-8 string with the supported character(s) used to surround a delimited identifier.
   *
   * @generated from enum value: SQL_IDENTIFIER_QUOTE_CHAR = 504;
   */
  SQL_IDENTIFIER_QUOTE_CHAR = 504,

  /**
   *
   * Retrieves a int32 describing the case sensitivity of quoted identifiers.
   *
   * The possible values are listed in `arrow.flight.protocol.sql.SqlSupportedCaseSensitivity`.
   *
   * @generated from enum value: SQL_QUOTED_IDENTIFIER_CASE = 505;
   */
  SQL_QUOTED_IDENTIFIER_CASE = 505,

  /**
   *
   * Retrieves a boolean value indicating whether all tables are selectable.
   *
   * Returns:
   * - false: if not all tables are selectable or if none are;
   * - true: if all tables are selectable.
   *
   * @generated from enum value: SQL_ALL_TABLES_ARE_SELECTABLE = 506;
   */
  SQL_ALL_TABLES_ARE_SELECTABLE = 506,

  /**
   *
   * Retrieves the null ordering.
   *
   * Returns a int32 ordinal for the null ordering being used, as described in
   * `arrow.flight.protocol.sql.SqlNullOrdering`.
   *
   * @generated from enum value: SQL_NULL_ORDERING = 507;
   */
  SQL_NULL_ORDERING = 507,

  /**
   * Retrieves a UTF-8 string list with values of the supported keywords.
   *
   * @generated from enum value: SQL_KEYWORDS = 508;
   */
  SQL_KEYWORDS = 508,

  /**
   * Retrieves a UTF-8 string list with values of the supported numeric functions.
   *
   * @generated from enum value: SQL_NUMERIC_FUNCTIONS = 509;
   */
  SQL_NUMERIC_FUNCTIONS = 509,

  /**
   * Retrieves a UTF-8 string list with values of the supported string functions.
   *
   * @generated from enum value: SQL_STRING_FUNCTIONS = 510;
   */
  SQL_STRING_FUNCTIONS = 510,

  /**
   * Retrieves a UTF-8 string list with values of the supported system functions.
   *
   * @generated from enum value: SQL_SYSTEM_FUNCTIONS = 511;
   */
  SQL_SYSTEM_FUNCTIONS = 511,

  /**
   * Retrieves a UTF-8 string list with values of the supported datetime functions.
   *
   * @generated from enum value: SQL_DATETIME_FUNCTIONS = 512;
   */
  SQL_DATETIME_FUNCTIONS = 512,

  /**
   *
   * Retrieves the UTF-8 string that can be used to escape wildcard characters.
   * This is the string that can be used to escape '_' or '%' in the catalog search parameters that are a pattern
   * (and therefore use one of the wildcard characters).
   * The '_' character represents any single character; the '%' character represents any sequence of zero or more
   * characters.
   *
   * @generated from enum value: SQL_SEARCH_STRING_ESCAPE = 513;
   */
  SQL_SEARCH_STRING_ESCAPE = 513,

  /**
   *
   * Retrieves a UTF-8 string with all the "extra" characters that can be used in unquoted identifier names
   * (those beyond a-z, A-Z, 0-9 and _).
   *
   * @generated from enum value: SQL_EXTRA_NAME_CHARACTERS = 514;
   */
  SQL_EXTRA_NAME_CHARACTERS = 514,

  /**
   *
   * Retrieves a boolean value indicating whether column aliasing is supported.
   * If so, the SQL AS clause can be used to provide names for computed columns or to provide alias names for columns
   * as required.
   *
   * Returns:
   * - false: if column aliasing is unsupported;
   * - true: if column aliasing is supported.
   *
   * @generated from enum value: SQL_SUPPORTS_COLUMN_ALIASING = 515;
   */
  SQL_SUPPORTS_COLUMN_ALIASING = 515,

  /**
   *
   * Retrieves a boolean value indicating whether concatenations between null and non-null values being
   * null are supported.
   *
   * - Returns:
   * - false: if concatenations between null and non-null values being null are unsupported;
   * - true: if concatenations between null and non-null values being null are supported.
   *
   * @generated from enum value: SQL_NULL_PLUS_NULL_IS_NULL = 516;
   */
  SQL_NULL_PLUS_NULL_IS_NULL = 516,

  /**
   *
   * Retrieves a map where the key is the type to convert from and the value is a list with the types to convert to,
   * indicating the supported conversions. Each key and each item on the list value is a value to a predefined type on
   * SqlSupportsConvert enum.
   * The returned map will be:  map<int32, list<int32>>
   *
   * @generated from enum value: SQL_SUPPORTS_CONVERT = 517;
   */
  SQL_SUPPORTS_CONVERT = 517,

  /**
   *
   * Retrieves a boolean value indicating whether, when table correlation names are supported,
   * they are restricted to being different from the names of the tables.
   *
   * Returns:
   * - false: if table correlation names are unsupported;
   * - true: if table correlation names are supported.
   *
   * @generated from enum value: SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518;
   */
  SQL_SUPPORTS_TABLE_CORRELATION_NAMES = 518,

  /**
   *
   * Retrieves a boolean value indicating whether, when table correlation names are supported,
   * they are restricted to being different from the names of the tables.
   *
   * Returns:
   * - false: if different table correlation names are unsupported;
   * - true: if different table correlation names are supported
   *
   * @generated from enum value: SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519;
   */
  SQL_SUPPORTS_DIFFERENT_TABLE_CORRELATION_NAMES = 519,

  /**
   *
   * Retrieves a boolean value indicating whether expressions in ORDER BY lists are supported.
   *
   * Returns:
   * - false: if expressions in ORDER BY are unsupported;
   * - true: if expressions in ORDER BY are supported;
   *
   * @generated from enum value: SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520;
   */
  SQL_SUPPORTS_EXPRESSIONS_IN_ORDER_BY = 520,

  /**
   *
   * Retrieves a boolean value indicating whether using a column that is not in the SELECT statement in a GROUP BY
   * clause is supported.
   *
   * Returns:
   * - false: if using a column that is not in the SELECT statement in a GROUP BY clause is unsupported;
   * - true: if using a column that is not in the SELECT statement in a GROUP BY clause is supported.
   *
   * @generated from enum value: SQL_SUPPORTS_ORDER_BY_UNRELATED = 521;
   */
  SQL_SUPPORTS_ORDER_BY_UNRELATED = 521,

  /**
   *
   * Retrieves the supported GROUP BY commands;
   *
   * Returns an int32 bitmask value representing the supported commands.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (GROUP BY is unsupported);
   * - return 1 (\b1)   => [SQL_GROUP_BY_UNRELATED];
   * - return 2 (\b10)  => [SQL_GROUP_BY_BEYOND_SELECT];
   * - return 3 (\b11)  => [SQL_GROUP_BY_UNRELATED, SQL_GROUP_BY_BEYOND_SELECT].
   * Valid GROUP BY types are described under `arrow.flight.protocol.sql.SqlSupportedGroupBy`.
   *
   * @generated from enum value: SQL_SUPPORTED_GROUP_BY = 522;
   */
  SQL_SUPPORTED_GROUP_BY = 522,

  /**
   *
   * Retrieves a boolean value indicating whether specifying a LIKE escape clause is supported.
   *
   * Returns:
   * - false: if specifying a LIKE escape clause is unsupported;
   * - true: if specifying a LIKE escape clause is supported.
   *
   * @generated from enum value: SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523;
   */
  SQL_SUPPORTS_LIKE_ESCAPE_CLAUSE = 523,

  /**
   *
   * Retrieves a boolean value indicating whether columns may be defined as non-nullable.
   *
   * Returns:
   * - false: if columns cannot be defined as non-nullable;
   * - true: if columns may be defined as non-nullable.
   *
   * @generated from enum value: SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524;
   */
  SQL_SUPPORTS_NON_NULLABLE_COLUMNS = 524,

  /**
   *
   * Retrieves the supported SQL grammar level as per the ODBC specification.
   *
   * Returns an int32 bitmask value representing the supported SQL grammar level.
   * The returned bitmask should be parsed in order to retrieve the supported grammar levels.
   *
   * For instance:
   * - return 0 (\b0)   => [] (SQL grammar is unsupported);
   * - return 1 (\b1)   => [SQL_MINIMUM_GRAMMAR];
   * - return 2 (\b10)  => [SQL_CORE_GRAMMAR];
   * - return 3 (\b11)  => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR];
   * - return 4 (\b100) => [SQL_EXTENDED_GRAMMAR];
   * - return 5 (\b101) => [SQL_MINIMUM_GRAMMAR, SQL_EXTENDED_GRAMMAR];
   * - return 6 (\b110) => [SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR];
   * - return 7 (\b111) => [SQL_MINIMUM_GRAMMAR, SQL_CORE_GRAMMAR, SQL_EXTENDED_GRAMMAR].
   * Valid SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedSqlGrammar`.
   *
   * @generated from enum value: SQL_SUPPORTED_GRAMMAR = 525;
   */
  SQL_SUPPORTED_GRAMMAR = 525,

  /**
   *
   * Retrieves the supported ANSI92 SQL grammar level.
   *
   * Returns an int32 bitmask value representing the supported ANSI92 SQL grammar level.
   * The returned bitmask should be parsed in order to retrieve the supported commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (ANSI92 SQL grammar is unsupported);
   * - return 1 (\b1)   => [ANSI92_ENTRY_SQL];
   * - return 2 (\b10)  => [ANSI92_INTERMEDIATE_SQL];
   * - return 3 (\b11)  => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL];
   * - return 4 (\b100) => [ANSI92_FULL_SQL];
   * - return 5 (\b101) => [ANSI92_ENTRY_SQL, ANSI92_FULL_SQL];
   * - return 6 (\b110) => [ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL];
   * - return 7 (\b111) => [ANSI92_ENTRY_SQL, ANSI92_INTERMEDIATE_SQL, ANSI92_FULL_SQL].
   * Valid ANSI92 SQL grammar levels are described under `arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel`.
   *
   * @generated from enum value: SQL_ANSI92_SUPPORTED_LEVEL = 526;
   */
  SQL_ANSI92_SUPPORTED_LEVEL = 526,

  /**
   *
   * Retrieves a boolean value indicating whether the SQL Integrity Enhancement Facility is supported.
   *
   * Returns:
   * - false: if the SQL Integrity Enhancement Facility is supported;
   * - true: if the SQL Integrity Enhancement Facility is supported.
   *
   * @generated from enum value: SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527;
   */
  SQL_SUPPORTS_INTEGRITY_ENHANCEMENT_FACILITY = 527,

  /**
   *
   * Retrieves the support level for SQL OUTER JOINs.
   *
   * Returns a int32 ordinal for the SQL ordering being used, as described in
   * `arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel`.
   *
   * @generated from enum value: SQL_OUTER_JOINS_SUPPORT_LEVEL = 528;
   */
  SQL_OUTER_JOINS_SUPPORT_LEVEL = 528,

  /**
   * Retrieves a UTF-8 string with the preferred term for "schema".
   *
   * @generated from enum value: SQL_SCHEMA_TERM = 529;
   */
  SQL_SCHEMA_TERM = 529,

  /**
   * Retrieves a UTF-8 string with the preferred term for "procedure".
   *
   * @generated from enum value: SQL_PROCEDURE_TERM = 530;
   */
  SQL_PROCEDURE_TERM = 530,

  /**
   *
   * Retrieves a UTF-8 string with the preferred term for "catalog".
   * If a empty string is returned its assumed that the server does NOT supports catalogs.
   *
   * @generated from enum value: SQL_CATALOG_TERM = 531;
   */
  SQL_CATALOG_TERM = 531,

  /**
   *
   * Retrieves a boolean value indicating whether a catalog appears at the start of a fully qualified table name.
   *
   * - false: if a catalog does not appear at the start of a fully qualified table name;
   * - true: if a catalog appears at the start of a fully qualified table name.
   *
   * @generated from enum value: SQL_CATALOG_AT_START = 532;
   */
  SQL_CATALOG_AT_START = 532,

  /**
   *
   * Retrieves the supported actions for a SQL schema.
   *
   * Returns an int32 bitmask value representing the supported actions for a SQL schema.
   * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL schema.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported actions for SQL schema);
   * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
   * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
   * Valid actions for a SQL schema described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
   *
   * @generated from enum value: SQL_SCHEMAS_SUPPORTED_ACTIONS = 533;
   */
  SQL_SCHEMAS_SUPPORTED_ACTIONS = 533,

  /**
   *
   * Retrieves the supported actions for a SQL schema.
   *
   * Returns an int32 bitmask value representing the supported actions for a SQL catalog.
   * The returned bitmask should be parsed in order to retrieve the supported actions for a SQL catalog.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported actions for SQL catalog);
   * - return 1 (\b1)   => [SQL_ELEMENT_IN_PROCEDURE_CALLS];
   * - return 2 (\b10)  => [SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 3 (\b11)  => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS];
   * - return 4 (\b100) => [SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 5 (\b101) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 6 (\b110) => [SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS];
   * - return 7 (\b111) => [SQL_ELEMENT_IN_PROCEDURE_CALLS, SQL_ELEMENT_IN_INDEX_DEFINITIONS, SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS].
   * Valid actions for a SQL catalog are described under `arrow.flight.protocol.sql.SqlSupportedElementActions`.
   *
   * @generated from enum value: SQL_CATALOGS_SUPPORTED_ACTIONS = 534;
   */
  SQL_CATALOGS_SUPPORTED_ACTIONS = 534,

  /**
   *
   * Retrieves the supported SQL positioned commands.
   *
   * Returns an int32 bitmask value representing the supported SQL positioned commands.
   * The returned bitmask should be parsed in order to retrieve the supported SQL positioned commands.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported SQL positioned commands);
   * - return 1 (\b1)   => [SQL_POSITIONED_DELETE];
   * - return 2 (\b10)  => [SQL_POSITIONED_UPDATE];
   * - return 3 (\b11)  => [SQL_POSITIONED_DELETE, SQL_POSITIONED_UPDATE].
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedPositionedCommands`.
   *
   * @generated from enum value: SQL_SUPPORTED_POSITIONED_COMMANDS = 535;
   */
  SQL_SUPPORTED_POSITIONED_COMMANDS = 535,

  /**
   *
   * Retrieves a boolean value indicating whether SELECT FOR UPDATE statements are supported.
   *
   * Returns:
   * - false: if SELECT FOR UPDATE statements are unsupported;
   * - true: if SELECT FOR UPDATE statements are supported.
   *
   * @generated from enum value: SQL_SELECT_FOR_UPDATE_SUPPORTED = 536;
   */
  SQL_SELECT_FOR_UPDATE_SUPPORTED = 536,

  /**
   *
   * Retrieves a boolean value indicating whether stored procedure calls that use the stored procedure escape syntax
   * are supported.
   *
   * Returns:
   * - false: if stored procedure calls that use the stored procedure escape syntax are unsupported;
   * - true: if stored procedure calls that use the stored procedure escape syntax are supported.
   *
   * @generated from enum value: SQL_STORED_PROCEDURES_SUPPORTED = 537;
   */
  SQL_STORED_PROCEDURES_SUPPORTED = 537,

  /**
   *
   * Retrieves the supported SQL subqueries.
   *
   * Returns an int32 bitmask value representing the supported SQL subqueries.
   * The returned bitmask should be parsed in order to retrieve the supported SQL subqueries.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported SQL subqueries);
   * - return 1   (\b1)     => [SQL_SUBQUERIES_IN_COMPARISONS];
   * - return 2   (\b10)    => [SQL_SUBQUERIES_IN_EXISTS];
   * - return 3   (\b11)    => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS];
   * - return 4   (\b100)   => [SQL_SUBQUERIES_IN_INS];
   * - return 5   (\b101)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS];
   * - return 6   (\b110)   => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_EXISTS];
   * - return 7   (\b111)   => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS];
   * - return 8   (\b1000)  => [SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 9   (\b1001)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 10  (\b1010)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 11  (\b1011)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 12  (\b1100)  => [SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 13  (\b1101)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 14  (\b1110)  => [SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - return 15  (\b1111)  => [SQL_SUBQUERIES_IN_COMPARISONS, SQL_SUBQUERIES_IN_EXISTS, SQL_SUBQUERIES_IN_INS, SQL_SUBQUERIES_IN_QUANTIFIEDS];
   * - ...
   * Valid SQL subqueries are described under `arrow.flight.protocol.sql.SqlSupportedSubqueries`.
   *
   * @generated from enum value: SQL_SUPPORTED_SUBQUERIES = 538;
   */
  SQL_SUPPORTED_SUBQUERIES = 538,

  /**
   *
   * Retrieves a boolean value indicating whether correlated subqueries are supported.
   *
   * Returns:
   * - false: if correlated subqueries are unsupported;
   * - true: if correlated subqueries are supported.
   *
   * @generated from enum value: SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539;
   */
  SQL_CORRELATED_SUBQUERIES_SUPPORTED = 539,

  /**
   *
   * Retrieves the supported SQL UNIONs.
   *
   * Returns an int32 bitmask value representing the supported SQL UNIONs.
   * The returned bitmask should be parsed in order to retrieve the supported SQL UNIONs.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported SQL positioned commands);
   * - return 1 (\b1)   => [SQL_UNION];
   * - return 2 (\b10)  => [SQL_UNION_ALL];
   * - return 3 (\b11)  => [SQL_UNION, SQL_UNION_ALL].
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlSupportedUnions`.
   *
   * @generated from enum value: SQL_SUPPORTED_UNIONS = 540;
   */
  SQL_SUPPORTED_UNIONS = 540,

  /**
   * Retrieves a int64 value representing the maximum number of hex characters allowed in an inline binary literal.
   *
   * @generated from enum value: SQL_MAX_BINARY_LITERAL_LENGTH = 541;
   */
  SQL_MAX_BINARY_LITERAL_LENGTH = 541,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed for a character literal.
   *
   * @generated from enum value: SQL_MAX_CHAR_LITERAL_LENGTH = 542;
   */
  SQL_MAX_CHAR_LITERAL_LENGTH = 542,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed for a column name.
   *
   * @generated from enum value: SQL_MAX_COLUMN_NAME_LENGTH = 543;
   */
  SQL_MAX_COLUMN_NAME_LENGTH = 543,

  /**
   * Retrieves a int64 value representing the maximum number of columns allowed in a GROUP BY clause.
   *
   * @generated from enum value: SQL_MAX_COLUMNS_IN_GROUP_BY = 544;
   */
  SQL_MAX_COLUMNS_IN_GROUP_BY = 544,

  /**
   * Retrieves a int64 value representing the maximum number of columns allowed in an index.
   *
   * @generated from enum value: SQL_MAX_COLUMNS_IN_INDEX = 545;
   */
  SQL_MAX_COLUMNS_IN_INDEX = 545,

  /**
   * Retrieves a int64 value representing the maximum number of columns allowed in an ORDER BY clause.
   *
   * @generated from enum value: SQL_MAX_COLUMNS_IN_ORDER_BY = 546;
   */
  SQL_MAX_COLUMNS_IN_ORDER_BY = 546,

  /**
   * Retrieves a int64 value representing the maximum number of columns allowed in a SELECT list.
   *
   * @generated from enum value: SQL_MAX_COLUMNS_IN_SELECT = 547;
   */
  SQL_MAX_COLUMNS_IN_SELECT = 547,

  /**
   * Retrieves a int64 value representing the maximum number of columns allowed in a table.
   *
   * @generated from enum value: SQL_MAX_COLUMNS_IN_TABLE = 548;
   */
  SQL_MAX_COLUMNS_IN_TABLE = 548,

  /**
   * Retrieves a int64 value representing the maximum number of concurrent connections possible.
   *
   * @generated from enum value: SQL_MAX_CONNECTIONS = 549;
   */
  SQL_MAX_CONNECTIONS = 549,

  /**
   * Retrieves a int64 value the maximum number of characters allowed in a cursor name.
   *
   * @generated from enum value: SQL_MAX_CURSOR_NAME_LENGTH = 550;
   */
  SQL_MAX_CURSOR_NAME_LENGTH = 550,

  /**
   *
   * Retrieves a int64 value representing the maximum number of bytes allowed for an index,
   * including all of the parts of the index.
   *
   * @generated from enum value: SQL_MAX_INDEX_LENGTH = 551;
   */
  SQL_MAX_INDEX_LENGTH = 551,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed in a schema name.
   *
   * @generated from enum value: SQL_DB_SCHEMA_NAME_LENGTH = 552;
   */
  SQL_DB_SCHEMA_NAME_LENGTH = 552,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed in a procedure name.
   *
   * @generated from enum value: SQL_MAX_PROCEDURE_NAME_LENGTH = 553;
   */
  SQL_MAX_PROCEDURE_NAME_LENGTH = 553,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed in a catalog name.
   *
   * @generated from enum value: SQL_MAX_CATALOG_NAME_LENGTH = 554;
   */
  SQL_MAX_CATALOG_NAME_LENGTH = 554,

  /**
   * Retrieves a int64 value representing the maximum number of bytes allowed in a single row.
   *
   * @generated from enum value: SQL_MAX_ROW_SIZE = 555;
   */
  SQL_MAX_ROW_SIZE = 555,

  /**
   *
   * Retrieves a boolean indicating whether the return value for the JDBC method getMaxRowSize includes the SQL
   * data types LONGVARCHAR and LONGVARBINARY.
   *
   * Returns:
   * - false: if return value for the JDBC method getMaxRowSize does
   *          not include the SQL data types LONGVARCHAR and LONGVARBINARY;
   * - true: if return value for the JDBC method getMaxRowSize includes
   *         the SQL data types LONGVARCHAR and LONGVARBINARY.
   *
   * @generated from enum value: SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556;
   */
  SQL_MAX_ROW_SIZE_INCLUDES_BLOBS = 556,

  /**
   *
   * Retrieves a int64 value representing the maximum number of characters allowed for an SQL statement;
   * a result of 0 (zero) means that there is no limit or the limit is not known.
   *
   * @generated from enum value: SQL_MAX_STATEMENT_LENGTH = 557;
   */
  SQL_MAX_STATEMENT_LENGTH = 557,

  /**
   * Retrieves a int64 value representing the maximum number of active statements that can be open at the same time.
   *
   * @generated from enum value: SQL_MAX_STATEMENTS = 558;
   */
  SQL_MAX_STATEMENTS = 558,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed in a table name.
   *
   * @generated from enum value: SQL_MAX_TABLE_NAME_LENGTH = 559;
   */
  SQL_MAX_TABLE_NAME_LENGTH = 559,

  /**
   * Retrieves a int64 value representing the maximum number of tables allowed in a SELECT statement.
   *
   * @generated from enum value: SQL_MAX_TABLES_IN_SELECT = 560;
   */
  SQL_MAX_TABLES_IN_SELECT = 560,

  /**
   * Retrieves a int64 value representing the maximum number of characters allowed in a user name.
   *
   * @generated from enum value: SQL_MAX_USERNAME_LENGTH = 561;
   */
  SQL_MAX_USERNAME_LENGTH = 561,

  /**
   *
   * Retrieves this database's default transaction isolation level as described in
   * `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
   *
   * Returns a int32 ordinal for the SQL transaction isolation level.
   *
   * @generated from enum value: SQL_DEFAULT_TRANSACTION_ISOLATION = 562;
   */
  SQL_DEFAULT_TRANSACTION_ISOLATION = 562,

  /**
   *
   * Retrieves a boolean value indicating whether transactions are supported. If not, invoking the method commit is a
   * noop, and the isolation level is `arrow.flight.protocol.sql.SqlTransactionIsolationLevel.TRANSACTION_NONE`.
   *
   * Returns:
   * - false: if transactions are unsupported;
   * - true: if transactions are supported.
   *
   * @generated from enum value: SQL_TRANSACTIONS_SUPPORTED = 563;
   */
  SQL_TRANSACTIONS_SUPPORTED = 563,

  /**
   *
   * Retrieves the supported transactions isolation levels.
   *
   * Returns an int32 bitmask value representing the supported transactions isolation levels.
   * The returned bitmask should be parsed in order to retrieve the supported transactions isolation levels.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported SQL transactions isolation levels);
   * - return 1   (\b1)     => [SQL_TRANSACTION_NONE];
   * - return 2   (\b10)    => [SQL_TRANSACTION_READ_UNCOMMITTED];
   * - return 3   (\b11)    => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED];
   * - return 4   (\b100)   => [SQL_TRANSACTION_REPEATABLE_READ];
   * - return 5   (\b101)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 6   (\b110)   => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 7   (\b111)   => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 8   (\b1000)  => [SQL_TRANSACTION_REPEATABLE_READ];
   * - return 9   (\b1001)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 10  (\b1010)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 11  (\b1011)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 12  (\b1100)  => [SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 13  (\b1101)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 14  (\b1110)  => [SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 15  (\b1111)  => [SQL_TRANSACTION_NONE, SQL_TRANSACTION_READ_UNCOMMITTED, SQL_TRANSACTION_REPEATABLE_READ, SQL_TRANSACTION_REPEATABLE_READ];
   * - return 16  (\b10000) => [SQL_TRANSACTION_SERIALIZABLE];
   * - ...
   * Valid SQL positioned commands are described under `arrow.flight.protocol.sql.SqlTransactionIsolationLevel`.
   *
   * @generated from enum value: SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564;
   */
  SQL_SUPPORTED_TRANSACTIONS_ISOLATION_LEVELS = 564,

  /**
   *
   * Retrieves a boolean value indicating whether a data definition statement within a transaction forces
   * the transaction to commit.
   *
   * Returns:
   * - false: if a data definition statement within a transaction does not force the transaction to commit;
   * - true: if a data definition statement within a transaction forces the transaction to commit.
   *
   * @generated from enum value: SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565;
   */
  SQL_DATA_DEFINITION_CAUSES_TRANSACTION_COMMIT = 565,

  /**
   *
   * Retrieves a boolean value indicating whether a data definition statement within a transaction is ignored.
   *
   * Returns:
   * - false: if a data definition statement within a transaction is taken into account;
   * - true: a data definition statement within a transaction is ignored.
   *
   * @generated from enum value: SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566;
   */
  SQL_DATA_DEFINITIONS_IN_TRANSACTIONS_IGNORED = 566,

  /**
   *
   * Retrieves an int32 bitmask value representing the supported result set types.
   * The returned bitmask should be parsed in order to retrieve the supported result set types.
   *
   * For instance:
   * - return 0   (\b0)     => [] (no supported result set types);
   * - return 1   (\b1)     => [SQL_RESULT_SET_TYPE_UNSPECIFIED];
   * - return 2   (\b10)    => [SQL_RESULT_SET_TYPE_FORWARD_ONLY];
   * - return 3   (\b11)    => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY];
   * - return 4   (\b100)   => [SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 5   (\b101)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 6   (\b110)   => [SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 7   (\b111)   => [SQL_RESULT_SET_TYPE_UNSPECIFIED, SQL_RESULT_SET_TYPE_FORWARD_ONLY, SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE];
   * - return 8   (\b1000)  => [SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE];
   * - ...
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetType`.
   *
   * @generated from enum value: SQL_SUPPORTED_RESULT_SET_TYPES = 567;
   */
  SQL_SUPPORTED_RESULT_SET_TYPES = 567,

  /**
   *
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_UNSPECIFIED`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   *
   * @generated from enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568;
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_UNSPECIFIED = 568,

  /**
   *
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_FORWARD_ONLY`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   *
   * @generated from enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569;
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_FORWARD_ONLY = 569,

  /**
   *
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   *
   * @generated from enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570;
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_SENSITIVE = 570,

  /**
   *
   * Returns an int32 bitmask value concurrency types supported for
   * `arrow.flight.protocol.sql.SqlSupportedResultSetType.SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE`.
   *
   * For instance:
   * - return 0 (\b0)   => [] (no supported concurrency types for this result set type)
   * - return 1 (\b1)   => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED]
   * - return 2 (\b10)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 3 (\b11)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY]
   * - return 4 (\b100) => [SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 5 (\b101) => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 6 (\b110)  => [SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * - return 7 (\b111)  => [SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED, SQL_RESULT_SET_CONCURRENCY_READ_ONLY, SQL_RESULT_SET_CONCURRENCY_UPDATABLE]
   * Valid result set types are described under `arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency`.
   *
   * @generated from enum value: SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571;
   */
  SQL_SUPPORTED_CONCURRENCIES_FOR_RESULT_SET_SCROLL_INSENSITIVE = 571,

  /**
   *
   * Retrieves a boolean value indicating whether this database supports batch updates.
   *
   * - false: if this database does not support batch updates;
   * - true: if this database supports batch updates.
   *
   * @generated from enum value: SQL_BATCH_UPDATES_SUPPORTED = 572;
   */
  SQL_BATCH_UPDATES_SUPPORTED = 572,

  /**
   *
   * Retrieves a boolean value indicating whether this database supports savepoints.
   *
   * Returns:
   * - false: if this database does not support savepoints;
   * - true: if this database supports savepoints.
   *
   * @generated from enum value: SQL_SAVEPOINTS_SUPPORTED = 573;
   */
  SQL_SAVEPOINTS_SUPPORTED = 573,

  /**
   *
   * Retrieves a boolean value indicating whether named parameters are supported in callable statements.
   *
   * Returns:
   * - false: if named parameters in callable statements are unsupported;
   * - true: if named parameters in callable statements are supported.
   *
   * @generated from enum value: SQL_NAMED_PARAMETERS_SUPPORTED = 574;
   */
  SQL_NAMED_PARAMETERS_SUPPORTED = 574,

  /**
   *
   * Retrieves a boolean value indicating whether updates made to a LOB are made on a copy or directly to the LOB.
   *
   * Returns:
   * - false: if updates made to a LOB are made directly to the LOB;
   * - true: if updates made to a LOB are made on a copy.
   *
   * @generated from enum value: SQL_LOCATORS_UPDATE_COPY = 575;
   */
  SQL_LOCATORS_UPDATE_COPY = 575,

  /**
   *
   * Retrieves a boolean value indicating whether invoking user-defined or vendor functions
   * using the stored procedure escape syntax is supported.
   *
   * Returns:
   * - false: if invoking user-defined or vendor functions using the stored procedure escape syntax is unsupported;
   * - true: if invoking user-defined or vendor functions using the stored procedure escape syntax is supported.
   *
   * @generated from enum value: SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576;
   */
  SQL_STORED_FUNCTIONS_USING_CALL_SYNTAX_SUPPORTED = 576,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlInfo.
 */
export const SqlInfoSchema: GenEnum<SqlInfo> = /*@__PURE__*/
  enumDesc(file_FlightSql, 0);

/**
 * The level of support for Flight SQL transaction RPCs.
 *
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedTransaction
 */
export enum SqlSupportedTransaction {
  /**
   * Unknown/not indicated/no support
   *
   * @generated from enum value: SQL_SUPPORTED_TRANSACTION_NONE = 0;
   */
  NONE = 0,

  /**
   * Transactions, but not savepoints.
   * A savepoint is a mark within a transaction that can be individually
   * rolled back to. Not all databases support savepoints.
   *
   * @generated from enum value: SQL_SUPPORTED_TRANSACTION_TRANSACTION = 1;
   */
  TRANSACTION = 1,

  /**
   * Transactions and savepoints
   *
   * @generated from enum value: SQL_SUPPORTED_TRANSACTION_SAVEPOINT = 2;
   */
  SAVEPOINT = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedTransaction.
 */
export const SqlSupportedTransactionSchema: GenEnum<SqlSupportedTransaction> = /*@__PURE__*/
  enumDesc(file_FlightSql, 1);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedCaseSensitivity
 */
export enum SqlSupportedCaseSensitivity {
  /**
   * @generated from enum value: SQL_CASE_SENSITIVITY_UNKNOWN = 0;
   */
  SQL_CASE_SENSITIVITY_UNKNOWN = 0,

  /**
   * @generated from enum value: SQL_CASE_SENSITIVITY_CASE_INSENSITIVE = 1;
   */
  SQL_CASE_SENSITIVITY_CASE_INSENSITIVE = 1,

  /**
   * @generated from enum value: SQL_CASE_SENSITIVITY_UPPERCASE = 2;
   */
  SQL_CASE_SENSITIVITY_UPPERCASE = 2,

  /**
   * @generated from enum value: SQL_CASE_SENSITIVITY_LOWERCASE = 3;
   */
  SQL_CASE_SENSITIVITY_LOWERCASE = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedCaseSensitivity.
 */
export const SqlSupportedCaseSensitivitySchema: GenEnum<SqlSupportedCaseSensitivity> = /*@__PURE__*/
  enumDesc(file_FlightSql, 2);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlNullOrdering
 */
export enum SqlNullOrdering {
  /**
   * @generated from enum value: SQL_NULLS_SORTED_HIGH = 0;
   */
  SQL_NULLS_SORTED_HIGH = 0,

  /**
   * @generated from enum value: SQL_NULLS_SORTED_LOW = 1;
   */
  SQL_NULLS_SORTED_LOW = 1,

  /**
   * @generated from enum value: SQL_NULLS_SORTED_AT_START = 2;
   */
  SQL_NULLS_SORTED_AT_START = 2,

  /**
   * @generated from enum value: SQL_NULLS_SORTED_AT_END = 3;
   */
  SQL_NULLS_SORTED_AT_END = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlNullOrdering.
 */
export const SqlNullOrderingSchema: GenEnum<SqlNullOrdering> = /*@__PURE__*/
  enumDesc(file_FlightSql, 3);

/**
 * @generated from enum arrow.flight.protocol.sql.SupportedSqlGrammar
 */
export enum SupportedSqlGrammar {
  /**
   * @generated from enum value: SQL_MINIMUM_GRAMMAR = 0;
   */
  SQL_MINIMUM_GRAMMAR = 0,

  /**
   * @generated from enum value: SQL_CORE_GRAMMAR = 1;
   */
  SQL_CORE_GRAMMAR = 1,

  /**
   * @generated from enum value: SQL_EXTENDED_GRAMMAR = 2;
   */
  SQL_EXTENDED_GRAMMAR = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SupportedSqlGrammar.
 */
export const SupportedSqlGrammarSchema: GenEnum<SupportedSqlGrammar> = /*@__PURE__*/
  enumDesc(file_FlightSql, 4);

/**
 * @generated from enum arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel
 */
export enum SupportedAnsi92SqlGrammarLevel {
  /**
   * @generated from enum value: ANSI92_ENTRY_SQL = 0;
   */
  ANSI92_ENTRY_SQL = 0,

  /**
   * @generated from enum value: ANSI92_INTERMEDIATE_SQL = 1;
   */
  ANSI92_INTERMEDIATE_SQL = 1,

  /**
   * @generated from enum value: ANSI92_FULL_SQL = 2;
   */
  ANSI92_FULL_SQL = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SupportedAnsi92SqlGrammarLevel.
 */
export const SupportedAnsi92SqlGrammarLevelSchema: GenEnum<SupportedAnsi92SqlGrammarLevel> = /*@__PURE__*/
  enumDesc(file_FlightSql, 5);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel
 */
export enum SqlOuterJoinsSupportLevel {
  /**
   * @generated from enum value: SQL_JOINS_UNSUPPORTED = 0;
   */
  SQL_JOINS_UNSUPPORTED = 0,

  /**
   * @generated from enum value: SQL_LIMITED_OUTER_JOINS = 1;
   */
  SQL_LIMITED_OUTER_JOINS = 1,

  /**
   * @generated from enum value: SQL_FULL_OUTER_JOINS = 2;
   */
  SQL_FULL_OUTER_JOINS = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlOuterJoinsSupportLevel.
 */
export const SqlOuterJoinsSupportLevelSchema: GenEnum<SqlOuterJoinsSupportLevel> = /*@__PURE__*/
  enumDesc(file_FlightSql, 6);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedGroupBy
 */
export enum SqlSupportedGroupBy {
  /**
   * @generated from enum value: SQL_GROUP_BY_UNRELATED = 0;
   */
  SQL_GROUP_BY_UNRELATED = 0,

  /**
   * @generated from enum value: SQL_GROUP_BY_BEYOND_SELECT = 1;
   */
  SQL_GROUP_BY_BEYOND_SELECT = 1,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedGroupBy.
 */
export const SqlSupportedGroupBySchema: GenEnum<SqlSupportedGroupBy> = /*@__PURE__*/
  enumDesc(file_FlightSql, 7);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedElementActions
 */
export enum SqlSupportedElementActions {
  /**
   * @generated from enum value: SQL_ELEMENT_IN_PROCEDURE_CALLS = 0;
   */
  SQL_ELEMENT_IN_PROCEDURE_CALLS = 0,

  /**
   * @generated from enum value: SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1;
   */
  SQL_ELEMENT_IN_INDEX_DEFINITIONS = 1,

  /**
   * @generated from enum value: SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2;
   */
  SQL_ELEMENT_IN_PRIVILEGE_DEFINITIONS = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedElementActions.
 */
export const SqlSupportedElementActionsSchema: GenEnum<SqlSupportedElementActions> = /*@__PURE__*/
  enumDesc(file_FlightSql, 8);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedPositionedCommands
 */
export enum SqlSupportedPositionedCommands {
  /**
   * @generated from enum value: SQL_POSITIONED_DELETE = 0;
   */
  SQL_POSITIONED_DELETE = 0,

  /**
   * @generated from enum value: SQL_POSITIONED_UPDATE = 1;
   */
  SQL_POSITIONED_UPDATE = 1,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedPositionedCommands.
 */
export const SqlSupportedPositionedCommandsSchema: GenEnum<SqlSupportedPositionedCommands> = /*@__PURE__*/
  enumDesc(file_FlightSql, 9);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedSubqueries
 */
export enum SqlSupportedSubqueries {
  /**
   * @generated from enum value: SQL_SUBQUERIES_IN_COMPARISONS = 0;
   */
  SQL_SUBQUERIES_IN_COMPARISONS = 0,

  /**
   * @generated from enum value: SQL_SUBQUERIES_IN_EXISTS = 1;
   */
  SQL_SUBQUERIES_IN_EXISTS = 1,

  /**
   * @generated from enum value: SQL_SUBQUERIES_IN_INS = 2;
   */
  SQL_SUBQUERIES_IN_INS = 2,

  /**
   * @generated from enum value: SQL_SUBQUERIES_IN_QUANTIFIEDS = 3;
   */
  SQL_SUBQUERIES_IN_QUANTIFIEDS = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedSubqueries.
 */
export const SqlSupportedSubqueriesSchema: GenEnum<SqlSupportedSubqueries> = /*@__PURE__*/
  enumDesc(file_FlightSql, 10);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedUnions
 */
export enum SqlSupportedUnions {
  /**
   * @generated from enum value: SQL_UNION = 0;
   */
  SQL_UNION = 0,

  /**
   * @generated from enum value: SQL_UNION_ALL = 1;
   */
  SQL_UNION_ALL = 1,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedUnions.
 */
export const SqlSupportedUnionsSchema: GenEnum<SqlSupportedUnions> = /*@__PURE__*/
  enumDesc(file_FlightSql, 11);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlTransactionIsolationLevel
 */
export enum SqlTransactionIsolationLevel {
  /**
   * @generated from enum value: SQL_TRANSACTION_NONE = 0;
   */
  SQL_TRANSACTION_NONE = 0,

  /**
   * @generated from enum value: SQL_TRANSACTION_READ_UNCOMMITTED = 1;
   */
  SQL_TRANSACTION_READ_UNCOMMITTED = 1,

  /**
   * @generated from enum value: SQL_TRANSACTION_READ_COMMITTED = 2;
   */
  SQL_TRANSACTION_READ_COMMITTED = 2,

  /**
   * @generated from enum value: SQL_TRANSACTION_REPEATABLE_READ = 3;
   */
  SQL_TRANSACTION_REPEATABLE_READ = 3,

  /**
   * @generated from enum value: SQL_TRANSACTION_SERIALIZABLE = 4;
   */
  SQL_TRANSACTION_SERIALIZABLE = 4,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlTransactionIsolationLevel.
 */
export const SqlTransactionIsolationLevelSchema: GenEnum<SqlTransactionIsolationLevel> = /*@__PURE__*/
  enumDesc(file_FlightSql, 12);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedTransactions
 */
export enum SqlSupportedTransactions {
  /**
   * @generated from enum value: SQL_TRANSACTION_UNSPECIFIED = 0;
   */
  SQL_TRANSACTION_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SQL_DATA_DEFINITION_TRANSACTIONS = 1;
   */
  SQL_DATA_DEFINITION_TRANSACTIONS = 1,

  /**
   * @generated from enum value: SQL_DATA_MANIPULATION_TRANSACTIONS = 2;
   */
  SQL_DATA_MANIPULATION_TRANSACTIONS = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedTransactions.
 */
export const SqlSupportedTransactionsSchema: GenEnum<SqlSupportedTransactions> = /*@__PURE__*/
  enumDesc(file_FlightSql, 13);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedResultSetType
 */
export enum SqlSupportedResultSetType {
  /**
   * @generated from enum value: SQL_RESULT_SET_TYPE_UNSPECIFIED = 0;
   */
  SQL_RESULT_SET_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1;
   */
  SQL_RESULT_SET_TYPE_FORWARD_ONLY = 1,

  /**
   * @generated from enum value: SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 2;
   */
  SQL_RESULT_SET_TYPE_SCROLL_INSENSITIVE = 2,

  /**
   * @generated from enum value: SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 3;
   */
  SQL_RESULT_SET_TYPE_SCROLL_SENSITIVE = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedResultSetType.
 */
export const SqlSupportedResultSetTypeSchema: GenEnum<SqlSupportedResultSetType> = /*@__PURE__*/
  enumDesc(file_FlightSql, 14);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency
 */
export enum SqlSupportedResultSetConcurrency {
  /**
   * @generated from enum value: SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0;
   */
  SQL_RESULT_SET_CONCURRENCY_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1;
   */
  SQL_RESULT_SET_CONCURRENCY_READ_ONLY = 1,

  /**
   * @generated from enum value: SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2;
   */
  SQL_RESULT_SET_CONCURRENCY_UPDATABLE = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportedResultSetConcurrency.
 */
export const SqlSupportedResultSetConcurrencySchema: GenEnum<SqlSupportedResultSetConcurrency> = /*@__PURE__*/
  enumDesc(file_FlightSql, 15);

/**
 * @generated from enum arrow.flight.protocol.sql.SqlSupportsConvert
 */
export enum SqlSupportsConvert {
  /**
   * @generated from enum value: SQL_CONVERT_BIGINT = 0;
   */
  SQL_CONVERT_BIGINT = 0,

  /**
   * @generated from enum value: SQL_CONVERT_BINARY = 1;
   */
  SQL_CONVERT_BINARY = 1,

  /**
   * @generated from enum value: SQL_CONVERT_BIT = 2;
   */
  SQL_CONVERT_BIT = 2,

  /**
   * @generated from enum value: SQL_CONVERT_CHAR = 3;
   */
  SQL_CONVERT_CHAR = 3,

  /**
   * @generated from enum value: SQL_CONVERT_DATE = 4;
   */
  SQL_CONVERT_DATE = 4,

  /**
   * @generated from enum value: SQL_CONVERT_DECIMAL = 5;
   */
  SQL_CONVERT_DECIMAL = 5,

  /**
   * @generated from enum value: SQL_CONVERT_FLOAT = 6;
   */
  SQL_CONVERT_FLOAT = 6,

  /**
   * @generated from enum value: SQL_CONVERT_INTEGER = 7;
   */
  SQL_CONVERT_INTEGER = 7,

  /**
   * @generated from enum value: SQL_CONVERT_INTERVAL_DAY_TIME = 8;
   */
  SQL_CONVERT_INTERVAL_DAY_TIME = 8,

  /**
   * @generated from enum value: SQL_CONVERT_INTERVAL_YEAR_MONTH = 9;
   */
  SQL_CONVERT_INTERVAL_YEAR_MONTH = 9,

  /**
   * @generated from enum value: SQL_CONVERT_LONGVARBINARY = 10;
   */
  SQL_CONVERT_LONGVARBINARY = 10,

  /**
   * @generated from enum value: SQL_CONVERT_LONGVARCHAR = 11;
   */
  SQL_CONVERT_LONGVARCHAR = 11,

  /**
   * @generated from enum value: SQL_CONVERT_NUMERIC = 12;
   */
  SQL_CONVERT_NUMERIC = 12,

  /**
   * @generated from enum value: SQL_CONVERT_REAL = 13;
   */
  SQL_CONVERT_REAL = 13,

  /**
   * @generated from enum value: SQL_CONVERT_SMALLINT = 14;
   */
  SQL_CONVERT_SMALLINT = 14,

  /**
   * @generated from enum value: SQL_CONVERT_TIME = 15;
   */
  SQL_CONVERT_TIME = 15,

  /**
   * @generated from enum value: SQL_CONVERT_TIMESTAMP = 16;
   */
  SQL_CONVERT_TIMESTAMP = 16,

  /**
   * @generated from enum value: SQL_CONVERT_TINYINT = 17;
   */
  SQL_CONVERT_TINYINT = 17,

  /**
   * @generated from enum value: SQL_CONVERT_VARBINARY = 18;
   */
  SQL_CONVERT_VARBINARY = 18,

  /**
   * @generated from enum value: SQL_CONVERT_VARCHAR = 19;
   */
  SQL_CONVERT_VARCHAR = 19,
}

/**
 * Describes the enum arrow.flight.protocol.sql.SqlSupportsConvert.
 */
export const SqlSupportsConvertSchema: GenEnum<SqlSupportsConvert> = /*@__PURE__*/
  enumDesc(file_FlightSql, 16);

/**
 * *
 * The JDBC/ODBC-defined type of any object.
 * All the values here are the same as in the JDBC and ODBC specs.
 *
 * @generated from enum arrow.flight.protocol.sql.XdbcDataType
 */
export enum XdbcDataType {
  /**
   * @generated from enum value: XDBC_UNKNOWN_TYPE = 0;
   */
  XDBC_UNKNOWN_TYPE = 0,

  /**
   * @generated from enum value: XDBC_CHAR = 1;
   */
  XDBC_CHAR = 1,

  /**
   * @generated from enum value: XDBC_NUMERIC = 2;
   */
  XDBC_NUMERIC = 2,

  /**
   * @generated from enum value: XDBC_DECIMAL = 3;
   */
  XDBC_DECIMAL = 3,

  /**
   * @generated from enum value: XDBC_INTEGER = 4;
   */
  XDBC_INTEGER = 4,

  /**
   * @generated from enum value: XDBC_SMALLINT = 5;
   */
  XDBC_SMALLINT = 5,

  /**
   * @generated from enum value: XDBC_FLOAT = 6;
   */
  XDBC_FLOAT = 6,

  /**
   * @generated from enum value: XDBC_REAL = 7;
   */
  XDBC_REAL = 7,

  /**
   * @generated from enum value: XDBC_DOUBLE = 8;
   */
  XDBC_DOUBLE = 8,

  /**
   * @generated from enum value: XDBC_DATETIME = 9;
   */
  XDBC_DATETIME = 9,

  /**
   * @generated from enum value: XDBC_INTERVAL = 10;
   */
  XDBC_INTERVAL = 10,

  /**
   * @generated from enum value: XDBC_VARCHAR = 12;
   */
  XDBC_VARCHAR = 12,

  /**
   * @generated from enum value: XDBC_DATE = 91;
   */
  XDBC_DATE = 91,

  /**
   * @generated from enum value: XDBC_TIME = 92;
   */
  XDBC_TIME = 92,

  /**
   * @generated from enum value: XDBC_TIMESTAMP = 93;
   */
  XDBC_TIMESTAMP = 93,

  /**
   * @generated from enum value: XDBC_LONGVARCHAR = -1;
   */
  XDBC_LONGVARCHAR = -1,

  /**
   * @generated from enum value: XDBC_BINARY = -2;
   */
  XDBC_BINARY = -2,

  /**
   * @generated from enum value: XDBC_VARBINARY = -3;
   */
  XDBC_VARBINARY = -3,

  /**
   * @generated from enum value: XDBC_LONGVARBINARY = -4;
   */
  XDBC_LONGVARBINARY = -4,

  /**
   * @generated from enum value: XDBC_BIGINT = -5;
   */
  XDBC_BIGINT = -5,

  /**
   * @generated from enum value: XDBC_TINYINT = -6;
   */
  XDBC_TINYINT = -6,

  /**
   * @generated from enum value: XDBC_BIT = -7;
   */
  XDBC_BIT = -7,

  /**
   * @generated from enum value: XDBC_WCHAR = -8;
   */
  XDBC_WCHAR = -8,

  /**
   * @generated from enum value: XDBC_WVARCHAR = -9;
   */
  XDBC_WVARCHAR = -9,
}

/**
 * Describes the enum arrow.flight.protocol.sql.XdbcDataType.
 */
export const XdbcDataTypeSchema: GenEnum<XdbcDataType> = /*@__PURE__*/
  enumDesc(file_FlightSql, 17);

/**
 * *
 * Detailed subtype information for XDBC_TYPE_DATETIME and XDBC_TYPE_INTERVAL.
 *
 * @generated from enum arrow.flight.protocol.sql.XdbcDatetimeSubcode
 */
export enum XdbcDatetimeSubcode {
  /**
   * @generated from enum value: XDBC_SUBCODE_UNKNOWN = 0;
   */
  XDBC_SUBCODE_UNKNOWN = 0,

  /**
   * @generated from enum value: XDBC_SUBCODE_YEAR = 1;
   */
  XDBC_SUBCODE_YEAR = 1,

  /**
   * @generated from enum value: XDBC_SUBCODE_DATE = 1;
   */
  XDBC_SUBCODE_DATE = 1,

  /**
   * @generated from enum value: XDBC_SUBCODE_TIME = 2;
   */
  XDBC_SUBCODE_TIME = 2,

  /**
   * @generated from enum value: XDBC_SUBCODE_MONTH = 2;
   */
  XDBC_SUBCODE_MONTH = 2,

  /**
   * @generated from enum value: XDBC_SUBCODE_TIMESTAMP = 3;
   */
  XDBC_SUBCODE_TIMESTAMP = 3,

  /**
   * @generated from enum value: XDBC_SUBCODE_DAY = 3;
   */
  XDBC_SUBCODE_DAY = 3,

  /**
   * @generated from enum value: XDBC_SUBCODE_TIME_WITH_TIMEZONE = 4;
   */
  XDBC_SUBCODE_TIME_WITH_TIMEZONE = 4,

  /**
   * @generated from enum value: XDBC_SUBCODE_HOUR = 4;
   */
  XDBC_SUBCODE_HOUR = 4,

  /**
   * @generated from enum value: XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE = 5;
   */
  XDBC_SUBCODE_TIMESTAMP_WITH_TIMEZONE = 5,

  /**
   * @generated from enum value: XDBC_SUBCODE_MINUTE = 5;
   */
  XDBC_SUBCODE_MINUTE = 5,

  /**
   * @generated from enum value: XDBC_SUBCODE_SECOND = 6;
   */
  XDBC_SUBCODE_SECOND = 6,

  /**
   * @generated from enum value: XDBC_SUBCODE_YEAR_TO_MONTH = 7;
   */
  XDBC_SUBCODE_YEAR_TO_MONTH = 7,

  /**
   * @generated from enum value: XDBC_SUBCODE_DAY_TO_HOUR = 8;
   */
  XDBC_SUBCODE_DAY_TO_HOUR = 8,

  /**
   * @generated from enum value: XDBC_SUBCODE_DAY_TO_MINUTE = 9;
   */
  XDBC_SUBCODE_DAY_TO_MINUTE = 9,

  /**
   * @generated from enum value: XDBC_SUBCODE_DAY_TO_SECOND = 10;
   */
  XDBC_SUBCODE_DAY_TO_SECOND = 10,

  /**
   * @generated from enum value: XDBC_SUBCODE_HOUR_TO_MINUTE = 11;
   */
  XDBC_SUBCODE_HOUR_TO_MINUTE = 11,

  /**
   * @generated from enum value: XDBC_SUBCODE_HOUR_TO_SECOND = 12;
   */
  XDBC_SUBCODE_HOUR_TO_SECOND = 12,

  /**
   * @generated from enum value: XDBC_SUBCODE_MINUTE_TO_SECOND = 13;
   */
  XDBC_SUBCODE_MINUTE_TO_SECOND = 13,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_YEAR = 101;
   */
  XDBC_SUBCODE_INTERVAL_YEAR = 101,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_MONTH = 102;
   */
  XDBC_SUBCODE_INTERVAL_MONTH = 102,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_DAY = 103;
   */
  XDBC_SUBCODE_INTERVAL_DAY = 103,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_HOUR = 104;
   */
  XDBC_SUBCODE_INTERVAL_HOUR = 104,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_MINUTE = 105;
   */
  XDBC_SUBCODE_INTERVAL_MINUTE = 105,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_SECOND = 106;
   */
  XDBC_SUBCODE_INTERVAL_SECOND = 106,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH = 107;
   */
  XDBC_SUBCODE_INTERVAL_YEAR_TO_MONTH = 107,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR = 108;
   */
  XDBC_SUBCODE_INTERVAL_DAY_TO_HOUR = 108,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE = 109;
   */
  XDBC_SUBCODE_INTERVAL_DAY_TO_MINUTE = 109,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND = 110;
   */
  XDBC_SUBCODE_INTERVAL_DAY_TO_SECOND = 110,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE = 111;
   */
  XDBC_SUBCODE_INTERVAL_HOUR_TO_MINUTE = 111,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND = 112;
   */
  XDBC_SUBCODE_INTERVAL_HOUR_TO_SECOND = 112,

  /**
   * @generated from enum value: XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND = 113;
   */
  XDBC_SUBCODE_INTERVAL_MINUTE_TO_SECOND = 113,
}

/**
 * Describes the enum arrow.flight.protocol.sql.XdbcDatetimeSubcode.
 */
export const XdbcDatetimeSubcodeSchema: GenEnum<XdbcDatetimeSubcode> = /*@__PURE__*/
  enumDesc(file_FlightSql, 18);

/**
 * @generated from enum arrow.flight.protocol.sql.Nullable
 */
export enum Nullable {
  /**
   * *
   * Indicates that the fields does not allow the use of null values.
   *
   * @generated from enum value: NULLABILITY_NO_NULLS = 0;
   */
  NULLABILITY_NO_NULLS = 0,

  /**
   * *
   * Indicates that the fields allow the use of null values.
   *
   * @generated from enum value: NULLABILITY_NULLABLE = 1;
   */
  NULLABILITY_NULLABLE = 1,

  /**
   * *
   * Indicates that nullability of the fields cannot be determined.
   *
   * @generated from enum value: NULLABILITY_UNKNOWN = 2;
   */
  NULLABILITY_UNKNOWN = 2,
}

/**
 * Describes the enum arrow.flight.protocol.sql.Nullable.
 */
export const NullableSchema: GenEnum<Nullable> = /*@__PURE__*/
  enumDesc(file_FlightSql, 19);

/**
 * @generated from enum arrow.flight.protocol.sql.Searchable
 */
export enum Searchable {
  /**
   * *
   * Indicates that column cannot be used in a WHERE clause.
   *
   * @generated from enum value: SEARCHABLE_NONE = 0;
   */
  NONE = 0,

  /**
   * *
   * Indicates that the column can be used in a WHERE clause if it is using a
   * LIKE operator.
   *
   * @generated from enum value: SEARCHABLE_CHAR = 1;
   */
  CHAR = 1,

  /**
   * *
   * Indicates that the column can be used In a WHERE clause with any
   * operator other than LIKE.
   *
   * - Allowed operators: comparison, quantified comparison, BETWEEN,
   *                      DISTINCT, IN, MATCH, and UNIQUE.
   *
   * @generated from enum value: SEARCHABLE_BASIC = 2;
   */
  BASIC = 2,

  /**
   * *
   * Indicates that the column can be used in a WHERE clause using any operator.
   *
   * @generated from enum value: SEARCHABLE_FULL = 3;
   */
  FULL = 3,
}

/**
 * Describes the enum arrow.flight.protocol.sql.Searchable.
 */
export const SearchableSchema: GenEnum<Searchable> = /*@__PURE__*/
  enumDesc(file_FlightSql, 20);

/**
 * @generated from enum arrow.flight.protocol.sql.UpdateDeleteRules
 */
export enum UpdateDeleteRules {
  /**
   * @generated from enum value: CASCADE = 0;
   */
  CASCADE = 0,

  /**
   * @generated from enum value: RESTRICT = 1;
   */
  RESTRICT = 1,

  /**
   * @generated from enum value: SET_NULL = 2;
   */
  SET_NULL = 2,

  /**
   * @generated from enum value: NO_ACTION = 3;
   */
  NO_ACTION = 3,

  /**
   * @generated from enum value: SET_DEFAULT = 4;
   */
  SET_DEFAULT = 4,
}

/**
 * Describes the enum arrow.flight.protocol.sql.UpdateDeleteRules.
 */
export const UpdateDeleteRulesSchema: GenEnum<UpdateDeleteRules> = /*@__PURE__*/
  enumDesc(file_FlightSql, 21);

/**
 * @generated from extension: bool experimental = 1000;
 */
export const experimental: GenExtension<MessageOptions, boolean> = /*@__PURE__*/
  extDesc(file_FlightSql, 0);

